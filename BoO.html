<!doctype html>
<html lang="zh-Hant">

<head>
  <meta charset="utf-8" />
  <meta name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=0.5,user-scalable=yes" />
  <title>BoO ç¾å ´ä½ˆå±€åŠ©æ‰‹ï¼ˆå®Œæ•´ç‰ˆï¼‰</title>
  <style>
    :root {
      --bg: #0f1720;
      --panel: #0b1220;
      --card: #0f1725;
      --accent: #10b981;
      --accent2: #3b82f6;
      --text: #e6eef2;
      --text-muted: #9fb6b0;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", sans-serif;
      background: linear-gradient(180deg, #061018, #071425);
      color: var(--text);
      overflow: hidden;
    }

    .app {
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 12px;
      height: 100vh;
      padding: 10px;
      box-sizing: border-box;
      position: relative;
    }

    /* è¡Œå‹•è£ç½®æ©«å‘æ¨¡å¼ */
    @media (max-width:900px) and (orientation: landscape) {
      .app {
        grid-template-columns: 1fr;
        grid-auto-rows: 1fr;
      }

      .side {
        height: 42vh;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }

      .main {
        height: 58vh;
      }

      .mobile-toolbar {
        display: flex;
      }
    }

    /* è¡Œå‹•è£ç½®ç¸±å‘æ¨¡å¼ */
    @media (max-width:900px) and (orientation: portrait) {
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
        padding: 6px;
        gap: 8px;
      }

      .side {
        height: auto;
        max-height: 55vh;
        overflow-y: auto;
      }

      .main {
        height: 45vh;
      }

      .mobile-toolbar {
        display: flex;
      }
    }

    .side {
      background: linear-gradient(180deg, var(--panel), #071623);
      padding: 14px;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, .6);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .side-content {
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    h2 {
      margin: 0 0 10px 0;
      font-size: 18px;
      color: #10b981;
    }

    h3 {
      margin: 15px 0 8px 0;
      font-size: 15px;
      color: #bfeee0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 4px;
    }

    label {
      display: block;
      margin-top: 12px;
      font-weight: 600;
      color: #bfeee0;
      font-size: 14px;
    }

    input[type="number"],
    select,
    input[type="text"] {
      width: 100%;
      padding: 10px;
      margin-top: 6px;
      border-radius: 8px;
      border: 0;
      background: rgba(7, 26, 33, 0.8);
      color: var(--text);
      font-size: 14px;
      box-sizing: border-box;
    }

    button {
      background: var(--accent);
      color: #042018;
      border: 0;
      padding: 10px 14px;
      border-radius: 8px;
      font-weight: 700;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
      touch-action: manipulation;
    }

    button:hover {
      background: #0cd493;
      transform: translateY(-1px);
    }

    button.secondary {
      background: var(--accent2);
      color: white;
    }

    button.small {
      padding: 8px 12px;
      font-size: 13px;
    }

    .muted {
      color: #9fb6b0;
      font-size: 13px;
      line-height: 1.4;
    }

    .items-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .item-btn {
      background: #062226;
      padding: 8px;
      border-radius: 8px;
      color: var(--text);
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, .03);
    }

    .map-wrap {
      background: linear-gradient(180deg, #081827, #04202a);
      border-radius: 12px;
      padding: 8px;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
      flex-wrap: wrap;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
    }

    #svgmap {
      flex: 1;
      width: 100%;
      border-radius: 8px;
      background: linear-gradient(180deg, #0b2230, #05202a);
      touch-action: pan-x pan-y pinch-zoom;
      position: relative;
      overflow: hidden;
    }

    .controls-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 8px;
    }

    .legend {
      position: absolute;
      right: 12px;
      top: 12px;
      background: rgba(0, 0, 0, .6);
      padding: 10px;
      border-radius: 8px;
      color: var(--text);
      font-size: 12px;
      backdrop-filter: blur(5px);
      z-index: 10;
    }

    .info {
      font-size: 13px;
      color: #cfeee2;
      margin-top: 8px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
    }

    .item-list-row {
      display: flex;
      gap: 6px;
      align-items: center;
      margin-top: 6px;
    }

    .list-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 10px;
      background: #061d22;
      border-radius: 8px;
      margin-bottom: 6px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .export-row {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .footer {
      font-size: 11px;
      color: #9fb6b0;
      margin-top: 12px;
      text-align: center;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* æ–°å¢çš„æ¨£å¼ */
    .mode-selector {
      display: flex;
      gap: 4px;
      background: rgba(0, 0, 0, 0.3);
      padding: 4px;
      border-radius: 8px;
    }

    .mode-btn {
      flex: 1;
      padding: 8px;
      border-radius: 6px;
      background: transparent;
      color: #9fb6b0;
      font-size: 13px;
      border: none;
      cursor: pointer;
      text-align: center;
    }

    .mode-btn.active {
      background: var(--accent);
      color: #042018;
      font-weight: bold;
    }

    .entrance-marker {
      fill: #ff6b6b;
      stroke: #fff;
      stroke-width: 2;
      cursor: move;
    }

    .entrance-label {
      fill: #fff;
      font-size: 12px;
      font-weight: bold;
      text-anchor: middle;
    }

    .item-edit-modal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--panel);
      padding: 20px;
      border-radius: 12px;
      z-index: 100;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
      min-width: 300px;
      max-width: 90vw;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .modal-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 99;
      backdrop-filter: blur(3px);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .modal-title {
      margin: 0;
      font-size: 18px;
    }

    .modal-close {
      background: none;
      border: none;
      color: #9fb6b0;
      font-size: 20px;
      cursor: pointer;
    }

    .mobile-toolbar {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(11, 18, 32, 0.9);
      padding: 10px;
      border-radius: 50px;
      gap: 10px;
      z-index: 50;
      backdrop-filter: blur(10px);
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
    }

    .mobile-toolbar button {
      border-radius: 50%;
      width: 50px;
      height: 50px;
      padding: 0;
    }

    .zoom-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      background: rgba(0, 0, 0, 0.6);
      padding: 8px;
      border-radius: 10px;
      z-index: 20;
    }

    .zoom-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--accent);
      color: white;
      border: none;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .tab-container {
      margin-top: 15px;
    }

    .tab-buttons {
      display: flex;
      gap: 4px;
      margin-bottom: 10px;
    }

    .tab-button {
      flex: 1;
      padding: 10px;
      background: rgba(0, 0, 0, 0.3);
      border: none;
      color: #9fb6b0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    .tab-button.active {
      background: var(--accent);
      color: #042018;
      font-weight: bold;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* åœ–ç¤ºé¡è‰² */
    .icon-personal {
      color: #10b981;
    }

    .icon-group {
      color: #3b82f6;
    }

    .icon-table {
      color: #f59e0b;
    }

    .icon-toilet {
      color: #8b5cf6;
    }

    .icon-kitchen {
      color: #ef4444;
    }

    .icon-command {
      color: #f97316;
    }

    .icon-storage {
      color: #6366f1;
    }

    .icon-medical {
      color: #ec4899;
    }

    .icon-entrance {
      color: #ff6b6b;
    }
  </style>
</head>

<body>
  <div class="app">
    <!-- è¡Œå‹•è£ç½®å·¥å…·åˆ— -->
    <div class="mobile-toolbar">
      <button id="mobileDrawBtn" title="ç¹ªè£½å ´åœ°">ğŸ“</button>
      <button id="mobileSelectBtn" title="é¸æ“‡æ¨¡å¼">ğŸ‘†</button>
      <button id="mobileZoomIn" title="æ”¾å¤§">â•</button>
      <button id="mobileZoomOut" title="ç¸®å°">â–</button>
      <button id="mobileAutoArrange" title="AIæ’ç‰ˆ">ğŸ¤–</button>
    </div>

    <div class="side">
      <h2>BoO ç¾å ´ä½ˆå±€åŠ©æ‰‹</h2>
      <div class="muted">å°ˆç‚ºæ•‘æ´ã€éœ²ç‡Ÿã€æ´»å‹•è¦åŠƒè¨­è¨ˆã€‚å…ˆåœ¨å³å´ç¹ªè£½å ´åœ°ç¯„åœï¼ŒåŠ å…¥ç‰©ä»¶å¾Œä½¿ç”¨ AI æ™ºèƒ½æ’ç‰ˆã€‚</div>

      <!-- æ¨¡å¼é¸æ“‡ -->
      <div class="mode-selector">
        <button class="mode-btn active" data-mode="draw">ç¹ªè£½å ´åœ°</button>
        <button class="mode-btn" data-mode="entrance">è¨­å®šå‡ºå…¥å£</button>
        <button class="mode-btn" data-mode="select">é¸æ“‡/ç·¨è¼¯</button>
      </div>

      <div class="side-content">
        <!-- æ¨™ç±¤é  -->
        <div class="tab-container">
          <div class="tab-buttons">
            <button class="tab-button active" data-tab="setup">å ´åœ°è¨­å®š</button>
            <button class="tab-button" data-tab="objects">ç‰©ä»¶ç®¡ç†</button>
            <button class="tab-button" data-tab="ai">AI æ’ç‰ˆ</button>
          </div>

          <!-- å ´åœ°è¨­å®šæ¨™ç±¤é  -->
          <div class="tab-content active" id="tab-setup">
            <label>åœ°åœ–æ¯”ä¾‹</label>
            <div class="controls-row">
              <input id="scale" type="number" min="1" step="1" value="10" style="width:120px" />
              <div class="muted" style="padding-left:6px">10 px = 1 å…¬å°º</div>
            </div>

            <label>å ´åœ°ç¹ªè£½</label>
            <div class="muted">é»æ“Šåœ°åœ–æ–°å¢é ‚é»ï¼Œé›™æ“Šå®Œæˆå¤šé‚Šå½¢</div>
            <div class="controls-row">
              <button id="clearBtn" class="small">æ¸…é™¤é‡ç•«</button>
              <button id="completeBtn" class="small">å®Œæˆç¹ªè£½</button>
              <button id="areaBtn" class="small">è¨ˆç®—é¢ç©</button>
            </div>
            <div class="info" id="areaInfo">å°šæœªå®šç¾©å ´åœ°ç¯„åœ</div>

            <label>å‡ºå…¥å£è¨­å®š</label>
            <div class="muted">è¨­å®šä¸»è¦å‡ºå…¥å£ï¼ˆAIæ’ç‰ˆæ™‚æœƒä¿ç•™é€šé“ï¼‰</div>
            <div class="controls-row">
              <button id="addEntranceBtn" class="small">æ–°å¢å‡ºå…¥å£</button>
              <button id="clearEntranceBtn" class="small secondary">æ¸…é™¤æ‰€æœ‰å‡ºå…¥å£</button>
            </div>
            <div class="info" id="entranceInfo">æœªè¨­å®šå‡ºå…¥å£</div>
          </div>

          <!-- ç‰©ä»¶ç®¡ç†æ¨™ç±¤é  -->
          <div class="tab-content" id="tab-objects">
            <label>æ–°å¢ç‰©ä»¶</label>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <select id="itemType" style="flex:1">
                <option value="personal_tent">å€‹äººå¸³ç¯·</option>
                <option value="group_tent">åœ˜é«”å¸³ç¯·</option>
                <option value="table">æŠ˜ç–Šæ¡Œ</option>
                <option value="toilet">ç§»å‹•å»æ‰€</option>
                <option value="kitchen">ç‚Šäº‹å€</option>
                <option value="command">æŒ‡æ®ä¸­å¿ƒ</option>
                <option value="storage">è£å‚™å„²å­˜å€</option>
                <option value="medical">é†«ç™‚å¸³ç¯·</option>
                <option value="power">ç™¼é›»æ©Ÿ/é›»æº</option>
                <option value="water">é£²æ°´ç«™</option>
                <option value="shower">æ·‹æµ´é–“</option>
                <option value="waste">å»¢æ£„ç‰©å€</option>
              </select>
            </div>

            <div style="display:flex;gap:8px;margin-top:8px">
              <div style="flex:1">
                <div class="muted" style="font-size:12px;margin-bottom:2px">é•·åº¦ (å…¬å°º)</div>
                <input id="itemW" type="number" placeholder="ä¾‹å¦‚ï¼š2" value="2" min="0.5" step="0.1" />
              </div>
              <div style="flex:1">
                <div class="muted" style="font-size:12px;margin-bottom:2px">å¯¬åº¦ (å…¬å°º)</div>
                <input id="itemH" type="number" placeholder="ä¾‹å¦‚ï¼š2" value="2" min="0.5" step="0.1" />
              </div>
              <div style="width:100px">
                <div class="muted" style="font-size:12px;margin-bottom:2px">æ•¸é‡ (å€‹)</div>
                <input id="itemCount" type="number" min="1" value="4" placeholder="æ•¸é‡" />
              </div>
            </div>

            <div style="display:flex;gap:8px;margin-top:8px">
              <select id="iconSel" style="flex:1">
                <option value="tent">â›º å¸³ç¯·</option>
                <option value="toilet">ğŸš» å»æ‰€</option>
                <option value="table">ğŸ›‹ï¸ æ¡Œæ¤…</option>
                <option value="fire">ğŸ”¥ ç‚Šäº‹</option>
                <option value="flag">ğŸ¯ æŒ‡æ®</option>
                <option value="box">ğŸ“¦ è£å‚™ç®±</option>
                <option value="med">ğŸ¥ é†«ç™‚</option>
                <option value="power">ğŸ”Œ é›»æº</option>
                <option value="water">ğŸ’§ é£²æ°´</option>
                <option value="shower">ğŸš¿ æ·‹æµ´</option>
                <option value="trash">ğŸ—‘ï¸ å»¢æ£„ç‰©</option>
              </select>
              <input id="customName" type="text" placeholder="è‡ªè¨‚åç¨±" style="width:120px" />
            </div>

            <div class="controls-row" style="margin-top:8px">
              <button id="addItemBtn" class="small" style="flex:1">åŠ å…¥ç‰©ä»¶æ¸…å–®</button>
            </div>

            <h3>å¾…æ’ç‰©ä»¶æ¸…å–®</h3>
            <div id="itemsContainer" style="margin-top:8px;max-height:200px;overflow-y:auto"></div>

            <div style="margin-top:15px">
              <button id="importLayoutBtn" class="small secondary" style="width:100%">åŒ¯å…¥ AI å»ºè­°ä½ˆå±€</button>
              <div class="muted" style="margin-top:6px">è¼‰å…¥ç³»çµ±å»ºè­°çš„ä½ˆå±€ç¯„æœ¬</div>
            </div>
          </div>

          <!-- AIæ’ç‰ˆæ¨™ç±¤é  -->
          <div class="tab-content" id="tab-ai">
            <h3>AI æ’ç‰ˆè¨­å®š</h3>
            <label>é€šé“å¯¬åº¦ (å…¬å°º)</label>
            <input id="aisleWidth" type="number" min="0.5" max="5" step="0.1" value="1.2" />

            <label>é‚Šç•Œè·é›¢ (å…¬å°º)</label>
            <input id="marginWidth" type="number" min="0.5" max="5" step="0.1" value="1.5" />

            <label>æ’åˆ—ç­–ç•¥</label>
            <select id="arrangeStrategy">
              <option value="row">è¡Œåˆ—å¼æ’åˆ—</option>
              <option value="cluster">åˆ†çµ„èšé›†æ’åˆ—</option>
              <option value="efficient">ç©ºé–“æœ€å„ªåŒ–</option>
              <option value="entrance">å‡ºå…¥å£å„ªå…ˆ</option>
            </select>

            <div style="margin-top:20px">
              <button id="autoBtn" style="width:100%">é–‹å§‹ AI æ™ºèƒ½æ’ç‰ˆ</button>
              <div class="muted" style="margin-top:6px">å°‡æ ¹æ“šå‡ºå…¥å£ã€é€šé“å¯¬åº¦æ™ºèƒ½æ’åˆ—ï¼Œå®Œæˆå¾Œå¯æ‹–æ›³å¾®èª¿ã€‚</div>
            </div>

            <div class="export-row" style="margin-top:20px">
              <button id="exportPNG" class="small">åŒ¯å‡º PNG åœ–ç‰‡</button>
              <button id="downloadJSON" class="small secondary">ä¸‹è¼‰ JSON æ•¸æ“š</button>
              <button id="clearPlaced" class="small">æ¸…é™¤æ‰€æœ‰æ’æ”¾</button>
            </div>
          </div>
        </div>
      </div>

      <div class="footer">
        <div>BoO ç¾å ´ä½ˆå±€åŠ©æ‰‹ v2.0</div>
        <div>æ”¯æ´æ•‘æ´ã€éœ²ç‡Ÿã€æ´»å‹•è¦åŠƒ | è§¸æ§å‹å–„è¨­è¨ˆ</div>
      </div>
    </div>

    <div class="main map-wrap">
      <div class="toolbar">
        <div class="small">ç›®å‰æ¨¡å¼ï¼š<span id="modeLabel" style="color:#10b981;font-weight:bold">ç¹ªè£½å ´åœ°</span></div>
        <div style="flex:1"></div>
        <div class="small muted" id="coordinateDisplay">é»æ“ŠæŸ¥çœ‹åº§æ¨™</div>
        <button id="centerViewBtn" class="small">ç½®ä¸­è¦–åœ–</button>
      </div>

      <div id="svgmap" tabindex="0">
        <!-- SVG å°‡ç”± JavaScript å‹•æ…‹å»ºç«‹ -->
      </div>

      <div class="zoom-controls">
        <button class="zoom-btn" id="zoomInBtn">+</button>
        <button class="zoom-btn" id="zoomOutBtn">-</button>
        <button class="zoom-btn" id="resetZoomBtn">â†º</button>
      </div>

      <div class="legend" id="legend">
        <div><strong>åœ–ä¾‹èªªæ˜ï¼š</strong></div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:6px;font-size:11px">
          <div><span style="color:#10b981">â›º</span> å€‹äººå¸³</div>
          <div><span style="color:#3b82f6">â›º</span> åœ˜é«”å¸³</div>
          <div><span style="color:#f59e0b">ğŸ›‹ï¸</span> æ¡Œæ¤…</div>
          <div><span style="color:#8b5cf6">ğŸš»</span> å»æ‰€</div>
          <div><span style="color:#ef4444">ğŸ”¥</span> ç‚Šäº‹</div>
          <div><span style="color:#f97316">ğŸ¯</span> æŒ‡æ®</div>
          <div><span style="color:#6366f1">ğŸ“¦</span> è£å‚™</div>
          <div><span style="color:#ec4899">ğŸ¥</span> é†«ç™‚</div>
          <div><span style="color:#ff6b6b">ğŸšª</span> å‡ºå…¥å£</div>
        </div>
      </div>
    </div>
  </div>

  <!-- ç·¨è¼¯æ¨¡æ…‹è¦–çª— -->
  <div id="editModal" class="item-edit-modal" style="display:none">
    <div class="modal-header">
      <h3 class="modal-title">ç·¨è¼¯ç‰©ä»¶</h3>
      <button class="modal-close" id="closeEditModal">&times;</button>
    </div>
    <div>
      <label>ç‰©ä»¶åç¨±</label>
      <input type="text" id="editItemName" placeholder="ä¾‹å¦‚ï¼šç”·ç”Ÿå¸³ç¯·ã€é†«ç™‚è£å‚™ç®±" />

      <label>å°ºå¯¸èª¿æ•´ (å…¬å°º)</label>
      <div style="display:flex;gap:8px">
        <input type="number" id="editItemWidth" placeholder="å¯¬åº¦" min="0.5" step="0.1" />
        <input type="number" id="editItemHeight" placeholder="é•·åº¦" min="0.5" step="0.1" />
      </div>

      <label>åœ–ç¤º</label>
      <select id="editItemIcon">
        <option value="â›º">â›º å¸³ç¯·</option>
        <option value="ğŸš»">ğŸš» å»æ‰€</option>
        <option value="ğŸ›‹ï¸">ğŸ›‹ï¸ æ¡Œæ¤…</option>
        <option value="ğŸ”¥">ğŸ”¥ ç‚Šäº‹</option>
        <option value="ğŸ¯">ğŸ¯ æŒ‡æ®</option>
        <option value="ğŸ“¦">ğŸ“¦ è£å‚™ç®±</option>
        <option value="ğŸ¥">ğŸ¥ é†«ç™‚</option>
        <option value="ğŸ”Œ">ğŸ”Œ é›»æº</option>
        <option value="ğŸ’§">ğŸ’§ é£²æ°´</option>
        <option value="ğŸš¿">ğŸš¿ æ·‹æµ´</option>
        <option value="ğŸ—‘ï¸">ğŸ—‘ï¸ å»¢æ£„ç‰©</option>
      </select>

      <div class="controls-row" style="margin-top:20px">
        <button id="saveEditBtn" style="flex:1">å„²å­˜è®Šæ›´</button>
        <button id="deleteItemBtn" class="secondary">åˆªé™¤ç‰©ä»¶</button>
      </div>
    </div>
  </div>
  <div id="modalOverlay" class="modal-overlay" style="display:none"></div>

  <script>
    // ========== å…¨åŸŸç‹€æ…‹è®Šæ•¸ ==========
    const state = {
      // å ´åœ°å¤šé‚Šå½¢ç›¸é—œ
      polygon: [],            // å¤šé‚Šå½¢é ‚é»åº§æ¨™ [x, y]
      polygonClosed: false,   // å¤šé‚Šå½¢æ˜¯å¦å·²å®Œæˆç¹ªè£½

      // ç‰©ä»¶ç®¡ç†
      placed: [],             // å·²æ”¾ç½®çš„ç‰©ä»¶
      itemsPool: [],          // å¾…æ’åˆ—çš„ç‰©ä»¶æ¸…å–®
      entrances: [],          // å‡ºå…¥å£ä½ç½® [{id, x, y, type}]

      // æ–°å¢ï¼šå˜æ¢ç»„å¼•ç”¨
      transformGroup: null,

      // é¡¯ç¤ºè¨­å®š
      scale: 10,              // åƒç´ /å…¬å°º æ¯”ä¾‹
      zoom: 1,                // ç¸®æ”¾ç´šåˆ¥
      pan: { x: 0, y: 0 },    // å¹³ç§»åç§»

      // SVG å…ƒç´ å¼•ç”¨
      svg: null,
      svgRoot: null,
      polyEl: null,
      pointsGroup: null,
      placedGroup: null,
      entranceGroup: null,

      // äº’å‹•ç‹€æ…‹
      currentMode: 'draw',    // ç›®å‰æ¨¡å¼: draw, entrance, select
      selectedItem: null,     // ç•¶å‰é¸ä¸­çš„ç‰©ä»¶
      isDragging: false,      // æ˜¯å¦æ­£åœ¨æ‹–æ›³
      dragItem: null,         // æ­£åœ¨æ‹–æ›³çš„ç‰©ä»¶
      dragOffset: { x: 0, y: 0 }, // æ‹–æ›³åç§»
      isDrawing: false,       // æ˜¯å¦æ­£åœ¨ç¹ªè£½å¤šé‚Šå½¢

      // è§¸æ§æ”¯æ´
      touchStart: null,       // è§¸æ§é–‹å§‹ä½ç½®
      touchZoom: 1,           // è§¸æ§ç¸®æ”¾åˆå§‹å€¼
      touchDistance: 0,       // å…©æŒ‡è·é›¢


    };

    // ========== SVG åœ°åœ–å»ºç«‹ ==========
    function createSvg() {
      const container = document.getElementById('svgmap');
      container.innerHTML = '';

      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');

      // é‡è¦ï¼šä½¿ç”¨å›ºå®š viewBoxï¼Œä¸è¦åŠ¨æ€ä¿®æ”¹å®ƒï¼
      svg.setAttribute('viewBox', '0 0 1200 700');
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

      // åˆ›å»ºå˜æ¢ç»„æ¥è¿›è¡Œç¼©æ”¾å’Œå¹³ç§»
      const transformGroup = document.createElementNS(svgNS, 'g');
      transformGroup.setAttribute('id', 'transform-group');

      container.appendChild(svg);
      state.svg = svg;

      // å»ºç«‹èƒŒæ™¯
      const bg = document.createElementNS(svgNS, 'rect');
      bg.setAttribute('x', 0);
      bg.setAttribute('y', 0);
      bg.setAttribute('width', 1200);
      bg.setAttribute('height', 700);
      bg.setAttribute('fill', 'rgba(2, 30, 36, 0.35)');
      svg.appendChild(bg);

      // å»ºç«‹åº§æ¨™æ ¼ç·š
      createGrid(svg);


      // === æ–°å¢ï¼šä¸­å¤®åƒè€ƒé»ï¼ˆç´…è‰²åœ“é»ï¼‰===
      const centerMarker = document.createElementNS(svgNS, 'g');
      const centerDot = document.createElementNS(svgNS, 'circle');
      centerDot.setAttribute('cx', 600); // 1200/2 = 600
      centerDot.setAttribute('cy', 350); // 700/2 = 350
      centerDot.setAttribute('r', 5);
      centerDot.setAttribute('fill', 'red');
      centerDot.setAttribute('stroke', 'white');
      centerDot.setAttribute('stroke-width', 2);
      centerMarker.appendChild(centerDot);

      const centerLabel = document.createElementNS(svgNS, 'text');
      centerLabel.setAttribute('x', 600);
      centerLabel.setAttribute('y', 365);
      centerLabel.setAttribute('text-anchor', 'middle');
      centerLabel.setAttribute('fill', 'white');
      centerLabel.setAttribute('font-size', '12');
      centerLabel.textContent = 'ä¸­å¿ƒé» (600,350)';
      centerMarker.appendChild(centerLabel);

      svg.appendChild(centerMarker); // ç›´æ¥æ·»åŠ åˆ°SVGï¼Œä¸åœ¨è®Šæ›çµ„å…§
      // === ä¸­å¤®åƒè€ƒé»çµæŸ ===
      // å°†å˜æ¢ç»„æ·»åŠ åˆ°SVGä¸­
      svg.appendChild(transformGroup);

      // å»ºç«‹å ´åœ°å¤šé‚Šå½¢å…ƒç´ ï¼ˆæ”¾åœ¨å˜æ¢ç»„å†…ï¼‰
      state.polyEl = document.createElementNS(svgNS, 'polygon');
      state.polyEl.setAttribute('fill', 'rgba(10, 40, 50, 0.3)');
      state.polyEl.setAttribute('stroke', '#32c7a6');
      state.polyEl.setAttribute('stroke-width', 2);
      state.polyEl.setAttribute('stroke-dasharray', '5,5');
      transformGroup.appendChild(state.polyEl);

      // å»ºç«‹é ‚é»ç¾¤çµ„
      state.pointsGroup = document.createElementNS(svgNS, 'g');
      transformGroup.appendChild(state.pointsGroup);

      // å»ºç«‹å‡ºå…¥å£ç¾¤çµ„
      state.entranceGroup = document.createElementNS(svgNS, 'g');
      transformGroup.appendChild(state.entranceGroup);

      // å»ºç«‹å·²æ”¾ç½®ç‰©ä»¶ç¾¤çµ„
      state.placedGroup = document.createElementNS(svgNS, 'g');
      transformGroup.appendChild(state.placedGroup);

      state.svgRoot = svg;
      state.transformGroup = transformGroup; // ä¿å­˜å˜æ¢ç»„å¼•ç”¨

      // è¨­å®šäº‹ä»¶ç›£è½å™¨
      setupEventListeners(svg);

      // åˆå§‹åŒ–è¦–åœ–ï¼ˆç°åœ¨é€šè¿‡å˜æ¢ç»„æ¥å®ç°ï¼‰
      updateViewTransform();
    }

    // ========== å»ºç«‹åº§æ¨™æ ¼ç·š ==========
    function createGrid(svg) {
      const svgNS = 'http://www.w3.org/2000/svg';
      const gridGroup = document.createElementNS(svgNS, 'g');
      gridGroup.setAttribute('id', 'grid-group');

      // ä¸»è¦æ ¼çº¿ (æ¯å…¬å°º) - æ”¾åœ¨èƒŒæ™¯å±‚
      for (let x = 0; x < 1200; x += state.scale) {
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', x);
        line.setAttribute('y1', 0);
        line.setAttribute('x2', x);
        line.setAttribute('y2', 700);
        line.setAttribute('stroke', 'rgba(255, 255, 255, 0.05)');
        line.setAttribute('stroke-width', 1);
        gridGroup.appendChild(line);
      }

      for (let y = 0; y < 700; y += state.scale) {
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', 0);
        line.setAttribute('y1', y);
        line.setAttribute('x2', 1200);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', 'rgba(255, 255, 255, 0.05)');
        line.setAttribute('stroke-width', 1);
        gridGroup.appendChild(line);
      }

      // æ¬¡è¦æ ¼çº¿ (æ¯5å…¬å°º)
      for (let x = 0; x < 1200; x += state.scale * 5) {
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', x);
        line.setAttribute('y1', 0);
        line.setAttribute('x2', x);
        line.setAttribute('y2', 700);
        line.setAttribute('stroke', 'rgba(255, 255, 255, 0.1)');
        line.setAttribute('stroke-width', 1.5);
        gridGroup.appendChild(line);
      }

      for (let y = 0; y < 700; y += state.scale * 5) {
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', 0);
        line.setAttribute('y1', y);
        line.setAttribute('x2', 1200);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', 'rgba(255, 255, 255, 0.1)');
        line.setAttribute('stroke-width', 1.5);
        gridGroup.appendChild(line);
      }

      // å°†ç½‘æ ¼ç»„æ·»åŠ åˆ°SVGä¸­ï¼ˆåœ¨èƒŒæ™¯ä¹‹åï¼Œå˜æ¢ç»„ä¹‹å‰ï¼‰
      svg.insertBefore(gridGroup, svg.children[1]);
    }
    // ========== è¨­å®šäº‹ä»¶ç›£è½å™¨ ==========
    function setupEventListeners(svg) {
      // ä¿®æ­£é»æ“Šåº§æ¨™è½‰æ›å‡½æ•¸
      function getSvgPoint(event) {
        const svg = state.svgRoot;
        if (!svg) return { x: 0, y: 0 };

        // ç²å–é»æ“Šä½ç½®
        let clientX, clientY;
        if (event.type.includes('touch')) {
          if (event.touches && event.touches.length > 0) {
            clientX = event.touches[0].clientX;
            clientY = event.touches[0].clientY;
          } else if (event.changedTouches && event.changedTouches.length > 0) {
            clientX = event.changedTouches[0].clientX;
            clientY = event.changedTouches[0].clientY;
          } else {
            return { x: 0, y: 0 };
          } 
        } else {
          clientX = event.clientX;
          clientY = event.clientY;
        }

        // ç²å–SVGä½ç½®å’Œå°ºå¯¸
        const rect = svg.getBoundingClientRect();

        // é‚Šç•Œæª¢æŸ¥
        if (rect.width === 0 || rect.height === 0) {
          return { x: 0, y: 0 };
        }

        // è¨ˆç®—åœ¨ viewBox (1200x700) ä¸­çš„ä½ç½®
        const viewBoxX = ((clientX - rect.left) / rect.width) * 1200;
        const viewBoxY = ((clientY - rect.top) / rect.height) * 700;

        // é€†è½‰è®Šæ›ï¼štranslate(pan.x, pan.y) scale(zoom)
        // è®Šæ›å…¬å¼ï¼šviewBox = pan + world * zoom
        // æ‰€ä»¥ï¼šworld = (viewBox - pan) / zoom
        const worldX = (viewBoxX - state.pan.x) / state.zoom;
        const worldY = (viewBoxY - state.pan.y) / state.zoom;

        return { x: worldX, y: worldY };
      }


      // é»æ“Šäº‹ä»¶
      svg.addEventListener('click', (event) => {
        event.preventDefault();
        const pt = getSvgPoint(event);

        console.log('ç‚¹å‡»ä½ç½®:', pt); // è°ƒè¯•ç”¨ï¼Œå¯ä»¥æŸ¥çœ‹ç‚¹å‡»åæ ‡

        switch (state.currentMode) {
          case 'draw':
            if (!state.polygonClosed) {
              addPolygonPoint(pt.x, pt.y);
            }
            break;

          case 'entrance':
            addEntrance(pt.x, pt.y);
            break;

          case 'select':
            const hit = hitTestPlaced(pt.x, pt.y);
            if (hit) {
              selectItem(hit);
            }
            break;
        }
      });

      // é›™æ“Šäº‹ä»¶
      svg.addEventListener('dblclick', (event) => {
        if (state.currentMode === 'draw' && state.polygon.length >= 3) {
          state.polygonClosed = true;
          renderPolygon();
          document.getElementById('modeLabel').textContent = 'ç¯„åœå·²å®šç¾©';
          showAreaInfo();

          // è‡ªå‹•åˆ‡æ›åˆ°é¸æ“‡æ¨¡å¼
          setMode('select');
        }
      });

      // æ‹–æ›³ç›¸é—œäº‹ä»¶
      let isDragging = false;
      let dragItem = null;
      let dragStartX = 0;
      let dragStartY = 0;
      let itemStartX = 0;
      let itemStartY = 0;

      svg.addEventListener('mousedown', (event) => {
        if (state.currentMode !== 'select') return;

        const pt = getSvgPoint(event);
        const hit = hitTestPlaced(pt.x, pt.y);

        if (hit) {
          isDragging = true;
          dragItem = hit;
          dragStartX = pt.x;
          dragStartY = pt.y;
          itemStartX = hit.x;
          itemStartY = hit.y;

          // è¦–è¦ºå›é¥‹
          selectItem(hit);
          event.preventDefault();
        }
      });

      svg.addEventListener('mousemove', (event) => {
        if (!isDragging || !dragItem) return;

        const pt = getSvgPoint(event);
        dragItem.x = itemStartX + (pt.x - dragStartX);
        dragItem.y = itemStartY + (pt.y - dragStartY);

        // ç¢ºä¿ç‰©ä»¶åœ¨å ´åœ°å…§
        constrainItemToPolygon(dragItem);

        updatePlacedGraphics();
        event.preventDefault();
      });

      svg.addEventListener('mouseup', () => {
        isDragging = false;
        dragItem = null;
      });

      // è§¸æ§äº‹ä»¶æ”¯æ´
      svg.addEventListener('touchstart', (event) => {
        if (event.touches.length === 1) {
          // å–®æŒ‡è§¸æ‘¸ - æ–°å¢é ‚é»æˆ–å‡ºå…¥å£
          event.preventDefault();
          const pt = getSvgPoint(event);

          // æ·»åŠ èª¿è©¦æ—¥èªŒ
          console.log('è§¸æ‘¸ä½ç½® - åŸå§‹:', {
            clientX: event.touches[0].clientX,
            clientY: event.touches[0].clientY
          });
          console.log('è§¸æ‘¸ä½ç½® - è½‰æ›å¾Œ:', pt);

          if (state.currentMode === 'draw' && !state.polygonClosed) {
            addPolygonPoint(pt.x, pt.y);
          } else if (state.currentMode === 'entrance') {
            addEntrance(pt.x, pt.y);
          } else if (state.currentMode === 'select') {
            const hit = hitTestPlaced(pt.x, pt.y);
            if (hit) {
              selectItem(hit);
            }
          }
        } else if (event.touches.length === 2) {
          // é›™æŒ‡è§¸æ‘¸ - é–‹å§‹ç¸®æ”¾
          event.preventDefault();
          state.touchStart = {
            x1: event.touches[0].clientX,
            y1: event.touches[0].clientY,
            x2: event.touches[1].clientX,
            y2: event.touches[1].clientY
          };
          state.touchZoom = state.zoom;
          state.touchDistance = Math.hypot(
            state.touchStart.x2 - state.touchStart.x1,
            state.touchStart.y2 - state.touchStart.y1
          );
        }
      });
      // 
      svg.addEventListener('touchmove', (event) => {
        if (event.touches.length === 2 && state.touchStart) {
          // åŒæŒ‡ç¼©æ”¾
          event.preventDefault();

          const currentDistance = Math.hypot(
            event.touches[1].clientX - event.touches[0].clientX,
            event.touches[1].clientY - event.touches[0].clientY
          );

          if (state.touchDistance > 0) {
            const scaleFactor = currentDistance / state.touchDistance;
            const newZoom = state.touchZoom * scaleFactor;

            // è¨ˆç®—ä¸­å¿ƒé»
            const centerX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
            const centerY = (event.touches[0].clientY + event.touches[1].clientY) / 2;

            const rect = svg.getBoundingClientRect();
            const viewBoxX = ((centerX - rect.left) / rect.width) * 1200;
            const viewBoxY = ((centerY - rect.top) / rect.height) * 700;

            const worldX = (viewBoxX - state.pan.x) / state.touchZoom;
            const worldY = (viewBoxY - state.pan.y) / state.touchZoom;

            state.zoom = Math.max(0.1, Math.min(5, newZoom));
            state.pan.x = viewBoxX - worldX * state.zoom;
            state.pan.y = viewBoxY - worldY * state.zoom;

            updateViewTransform();
          }
        } else if (event.touches.length === 1 && state.currentMode === 'select') {
          // å•æŒ‡æ‹–æ‹½ç‰©ä»¶
          const touch = event.touches[0];
          const pt = getSvgPoint(touch);

          // æŸ¥æ‰¾è¢«æ‹–æ‹½çš„ç‰©ä»¶
          if (!state.dragItem) {
            state.dragItem = hitTestPlaced(pt.x, pt.y);
            if (state.dragItem) {
              state.dragOffset = {
                x: pt.x - state.dragItem.x,
                y: pt.y - state.dragItem.y
              };
              event.preventDefault();
            }
          }

          if (state.dragItem) {
            state.dragItem.x = pt.x - state.dragOffset.x;
            state.dragItem.y = pt.y - state.dragOffset.y;
            constrainItemToPolygon(state.dragItem);
            updatePlacedGraphics();
            event.preventDefault();
          }
        }
      });

      let lastTap = 0;
      svg.addEventListener('touchend', (event) => {
        if (event.touches.length === 0) {
          const currentTime = Date.now();
          const tapLength = currentTime - lastTap;

          if (tapLength < 300 && tapLength > 0) {
            // æ£€æµ‹åˆ°åŒå‡»
            event.preventDefault();

            if (state.currentMode === 'draw' && state.polygon.length >= 3) {
              state.polygonClosed = true;
              renderPolygon();
              document.getElementById('modeLabel').textContent = 'èŒƒå›´å·²å®šä¹‰';
              showAreaInfo();
              setMode('select');
            }
          }
          lastTap = currentTime;
        }
      });

      // é˜²æ­¢æ»¾å‹•
      svg.addEventListener('wheel', (event) => {
        event.preventDefault();

        const rect = svg.getBoundingClientRect();

        // è¨ˆç®—æ»‘é¼ åœ¨SVGä¸­çš„ä½ç½®ï¼ˆ0-1200, 0-700ç¯„åœï¼‰
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        // è½‰æ›åˆ° viewBox åº§æ¨™ç³»
        const viewBoxX = (mouseX / rect.width) * 1200;
        const viewBoxY = (mouseY / rect.height) * 700;

        // è¨ˆç®—æ»‘é¼ ä½ç½®å°æ‡‰çš„ä¸–ç•Œåº§æ¨™ï¼ˆè®Šæ›å‰çš„åº§æ¨™ï¼‰
        const worldX = (viewBoxX - state.pan.x) / state.zoom;
        const worldY = (viewBoxY - state.pan.y) / state.zoom;

        // è¨ˆç®—ç¸®æ”¾å› å­
        const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
        const oldZoom = state.zoom;
        state.zoom = Math.max(0.1, Math.min(5, state.zoom * zoomFactor));

        // é‡æ–°è¨ˆç®—å¹³ç§»ï¼Œä½¿æ»‘é¼ ä½ç½®å°æ‡‰çš„ä¸–ç•Œåº§æ¨™ä¿æŒä¸è®Š
        // å…¬å¼æ¨å°ï¼š
        // ä¹‹å‰ï¼šviewBoxX = state.pan.x + worldX * oldZoom
        // ä¹‹å¾Œï¼šviewBoxX = newPan.x + worldX * newZoom
        // æ‰€ä»¥ï¼šnewPan.x = viewBoxX - worldX * newZoom
        state.pan.x = viewBoxX - worldX * state.zoom;
        state.pan.y = viewBoxY - worldY * state.zoom;

        updateViewTransform();

        console.log('æ»¾è¼ªç¸®æ”¾:', {
          mouse: { x: mouseX, y: mouseY },
          viewBox: { x: viewBoxX, y: viewBoxY },
          world: { x: worldX, y: worldY },
          oldZoom, newZoom: state.zoom,
          newPan: state.pan
        });
      });

    }
    // ========== å‚™ç”¨åº§æ¨™è½‰æ›æ–¹æ¡ˆ ==========
    function getSvgPointFallback(x, y, rect) {
      // è¨ˆç®—ç›¸å°ä½ç½®æ¯”ä¾‹
      const xRatio = x / rect.width;
      const yRatio = y / rect.height;

      // è½‰æ›åˆ° viewBox åº§æ¨™ç³» (1200x700)
      const viewBoxX = xRatio * 1200;
      const viewBoxY = yRatio * 700;

      // åå‘æ‡‰ç”¨è®Šæ›çµ„çš„è®Šæ›
      const transformedX = (viewBoxX - state.pan.x) / state.zoom;
      const transformedY = (viewBoxY - state.pan.y) / state.zoom;

      return { x: transformedX, y: transformedY };
    }
    // è¼”åŠ©å‡½æ•¸ï¼šå¾è¢å¹•åº§æ¨™è½‰æ›
    function getSvgPointFromScreen(screenX, screenY) {
      const svg = state.svgRoot;
      if (!svg) return { x: 0, y: 0 };

      const rect = svg.getBoundingClientRect();
      const x = screenX;
      const y = screenY;

      const svgX = (x / rect.width) * 1200;
      const svgY = (y / rect.height) * 700;

      const resultX = (svgX - state.pan.x) / state.zoom;
      const resultY = (svgY - state.pan.y) / state.zoom;

      return { x: resultX, y: resultY };
    }
    // ========== æ·»åŠ èª¿è©¦ç¶²æ ¼ ==========
    function addDebugGrid() {
      if (!state.svgRoot) return;

      const svgNS = 'http://www.w3.org/2000/svg';
      const gridGroup = document.createElementNS(svgNS, 'g');
      gridGroup.setAttribute('id', 'debug-grid');
      gridGroup.setAttribute('transform', state.transformGroup.getAttribute('transform'));

      // ç¶²æ ¼ç·š
      for (let x = 0; x <= 1200; x += 100) {
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', x);
        line.setAttribute('y1', 0);
        line.setAttribute('x2', x);
        line.setAttribute('y2', 700);
        line.setAttribute('stroke', x === 600 ? 'rgba(255, 0, 0, 0.3)' : 'rgba(0, 255, 0, 0.2)');
        line.setAttribute('stroke-width', x === 600 ? 2 : 1);
        line.setAttribute('stroke-dasharray', '5,5');
        gridGroup.appendChild(line);

        // æ¨™ç±¤
        const text = document.createElementNS(svgNS, 'text');
        text.setAttribute('x', x);
        text.setAttribute('y', 20);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('fill', x === 600 ? 'red' : 'green');
        text.setAttribute('font-size', '12');
        text.textContent = x;
        gridGroup.appendChild(text);
      }

      for (let y = 0; y <= 700; y += 100) {
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', 0);
        line.setAttribute('y1', y);
        line.setAttribute('x2', 1200);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', y === 350 ? 'rgba(255, 0, 0, 0.3)' : 'rgba(0, 255, 0, 0.2)');
        line.setAttribute('stroke-width', y === 350 ? 2 : 1);
        line.setAttribute('stroke-dasharray', '5,5');
        gridGroup.appendChild(line);

        // æ¨™ç±¤
        const text = document.createElementNS(svgNS, 'text');
        text.setAttribute('x', 20);
        text.setAttribute('y', y);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('fill', y === 350 ? 'red' : 'green');
        text.setAttribute('font-size', '12');
        text.textContent = y;
        gridGroup.appendChild(text);
      }

      state.svgRoot.appendChild(gridGroup);
    }
    // ========== æ›´æ–°è¦–åœ–è®Šæ› ==========
    function updateViewTransform() {
      if (!state.transformGroup) return;

      // é™åˆ¶ç¼©æ”¾èŒƒå›´
      state.zoom = Math.max(0.1, Math.min(5, state.zoom));

      // åˆ›å»ºå˜æ¢å­—ç¬¦ä¸²
      const transform = `translate(${state.pan.x}, ${state.pan.y}) scale(${state.zoom})`;

      // åº”ç”¨åˆ°å˜æ¢ç»„
      state.transformGroup.setAttribute('transform', transform);

      // æ›´æ–°èª¿è©¦ç¶²æ ¼
      updateDebugGrid();

      // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
      updateStatusDisplay();
    }

    // æ›´æ–°èª¿è©¦ç¶²æ ¼
    function updateDebugGrid() {
      const debugGrid = document.getElementById('debug-grid');
      if (debugGrid) {
        debugGrid.setAttribute('transform', state.transformGroup.getAttribute('transform'));
      }
    }
    // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
    function updateStatusDisplay() {
      const statusElement = document.getElementById('coordinateDisplay') || document.getElementById('statusDisplay');
      if (statusElement) {
        statusElement.innerHTML =
          `ç¸®æ”¾: ${state.zoom.toFixed(2)} | å¹³ç§»: (${state.pan.x.toFixed(0)}, ${state.pan.y.toFixed(0)})`;
      }
    }
    // ========== æ›´æ–°æ ¼çº¿æ˜¾ç¤º ==========
    function updateGridScale() {
      // å¦‚æœæ ¼çº¿éœ€è¦æ ¹æ®ç¼©æ”¾è°ƒæ•´ï¼Œå¯ä»¥åœ¨è¿™é‡Œå¤„ç†
      const gridLines = state.svgRoot.querySelectorAll('line');

      // æ ¹æ®ç¼©æ”¾è°ƒæ•´æ ¼çº¿ç²—ç»†
      const strokeWidth = 1 / Math.max(1, state.zoom);

      gridLines.forEach(line => {
        // ä¸»è¦æ ¼çº¿å’Œæ¬¡è¦æ ¼çº¿åŒºåˆ†
        const isMajor = parseFloat(line.getAttribute('stroke-width') || 1) === 1.5;
        line.setAttribute('stroke-width', isMajor ? strokeWidth * 1.5 : strokeWidth);
      });
    }
    // ========== å ´åœ°å¤šé‚Šå½¢åŠŸèƒ½ ==========
    // ========== æ·»åŠ é¡¶ç‚¹å‡½æ•° ==========
    function addPolygonPoint(x, y) {
      console.log(`æ·»åŠ é¡¶ç‚¹: (${x.toFixed(1)}, ${y.toFixed(1)})`); // è°ƒè¯•
      state.polygon.push([x, y]);
      renderPolygon();
    }

    function renderPolygon() {
      if (!state.polyEl) return;

      const points = state.polygon.map(p => p.join(',')).join(' ');
      state.polyEl.setAttribute('points', points);

      // æ›´æ–°é ‚é»é¡¯ç¤º
      state.pointsGroup.innerHTML = '';
      const svgNS = 'http://www.w3.org/2000/svg';

      state.polygon.forEach((point, index) => {
        const circle = document.createElementNS(svgNS, 'circle');
        circle.setAttribute('cx', point[0]);
        circle.setAttribute('cy', point[1]);
        circle.setAttribute('r', 6);
        circle.setAttribute('fill', '#10b981');
        circle.setAttribute('stroke', '#fff');
        circle.setAttribute('stroke-width', 2);
        circle.setAttribute('class', 'handle');
        circle.style.cursor = 'move';

        // é ‚é»å¯æ‹–æ›³èª¿æ•´
        circle.addEventListener('mousedown', (event) => {
          event.stopPropagation();
          let isDragging = true;
          const startX = event.clientX;
          const startY = event.clientY;
          const startPoint = [...point];

          function onMouseMove(moveEvent) {
            if (!isDragging) return;

            const dx = moveEvent.clientX - startX;
            const dy = moveEvent.clientY - startY;

            point[0] = startPoint[0] + dx / state.zoom;
            point[1] = startPoint[1] + dy / state.zoom;

            renderPolygon();
            showAreaInfo();
          }

          function onMouseUp() {
            isDragging = false;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          }

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });

        state.pointsGroup.appendChild(circle);
      });
    }

    // ========== è¨ˆç®—é¢ç©èˆ‡å‘¨é•· ==========
    function calculatePolygonArea(points) {
      let area = 0;
      const n = points.length;

      for (let i = 0; i < n; i++) {
        const [x1, y1] = points[i];
        const [x2, y2] = points[(i + 1) % n];
        area += x1 * y2 - x2 * y1;
      }

      return Math.abs(area) / 2;
    }

    function calculatePolygonPerimeter(points) {
      let perimeter = 0;
      const n = points.length;

      for (let i = 0; i < n; i++) {
        const [x1, y1] = points[i];
        const [x2, y2] = points[(i + 1) % n];
        perimeter += Math.hypot(x2 - x1, y2 - y1);
      }

      return perimeter;
    }

    function showAreaInfo() {
      if (!state.polygonClosed || state.polygon.length < 3) {
        document.getElementById('areaInfo').textContent = 'å ´åœ°å°šæœªå®Œæˆå®šç¾©';
        return;
      }

      const areaPx = calculatePolygonArea(state.polygon);
      const perimeterPx = calculatePolygonPerimeter(state.polygon);

      const areaM2 = (areaPx / (state.scale * state.scale)).toFixed(2);
      const perimeterM = (perimeterPx / state.scale).toFixed(2);

      document.getElementById('areaInfo').innerHTML =
        `å ´åœ°é¢ç©ï¼š<strong>${areaM2} å¹³æ–¹å…¬å°º</strong><br>` +
        `å ´åœ°å‘¨é•·ï¼š<strong>${perimeterM} å…¬å°º</strong>`;
    }

    // ========== å‡ºå…¥å£ç®¡ç† ==========
    function addEntrance(x, y) {
      console.log(`æ·»åŠ å‡ºå…¥å£: (${x.toFixed(1)}, ${y.toFixed(1)})`); // è°ƒè¯•

      if (state.entrances.length >= 4) {
        alert('æœ€å¤šåªèƒ½è¨­å®š 4 å€‹å‡ºå…¥å£');
        return;
      }

      const entranceId = `entrance_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const entrance = {
        id: entranceId,
        x: x,
        y: y,
        type: 'entrance',
        label: `å‡ºå…¥å£ ${state.entrances.length + 1}`
      };

      state.entrances.push(entrance);
      updateEntranceGraphics();
      updateEntranceInfo();
    }

    function updateEntranceGraphics() {
      if (!state.entranceGroup) return;

      state.entranceGroup.innerHTML = '';
      const svgNS = 'http://www.w3.org/2000/svg';

      state.entrances.forEach((entrance, index) => {
        // å‡ºå…¥å£åœ–ç¤º
        const group = document.createElementNS(svgNS, 'g');
        group.setAttribute('class', 'entrance-marker');
        group.setAttribute('transform', `translate(${entrance.x}, ${entrance.y})`);

        // ç®­é ­åœ–ç¤º
        const path = document.createElementNS(svgNS, 'path');
        path.setAttribute('d', 'M -15,-15 L 0,0 L -15,15 L -10,0 Z');
        path.setAttribute('fill', '#ff6b6b');
        path.setAttribute('stroke', '#fff');
        path.setAttribute('stroke-width', 2);

        // åœ“åœˆèƒŒæ™¯
        const circle = document.createElementNS(svgNS, 'circle');
        circle.setAttribute('cx', 0);
        circle.setAttribute('cy', 0);
        circle.setAttribute('r', 20);
        circle.setAttribute('fill', 'rgba(255, 107, 107, 0.2)');
        circle.setAttribute('stroke', '#ff6b6b');
        circle.setAttribute('stroke-width', 2);

        // æ¨™ç±¤
        const text = document.createElementNS(svgNS, 'text');
        text.setAttribute('x', 0);
        text.setAttribute('y', 30);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('class', 'entrance-label');
        text.textContent = entrance.label || `å‡ºå…¥å£ ${index + 1}`;

        group.appendChild(circle);
        group.appendChild(path);
        group.appendChild(text);

        // ä½¿å‡ºå…¥å£å¯æ‹–æ›³
        group.style.cursor = 'move';
        group.addEventListener('mousedown', (event) => {
          event.stopPropagation();
          let isDragging = true;
          const startX = event.clientX;
          const startY = event.clientY;
          const startEntranceX = entrance.x;
          const startEntranceY = entrance.y;

          function onMouseMove(moveEvent) {
            if (!isDragging) return;

            const dx = moveEvent.clientX - startX;
            const dy = moveEvent.clientY - startY;

            entrance.x = startEntranceX + dx / state.zoom;
            entrance.y = startEntranceY + dy / state.zoom;

            updateEntranceGraphics();
          }

          function onMouseUp() {
            isDragging = false;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            updateEntranceInfo();
          }

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });

        state.entranceGroup.appendChild(group);
      });
    }

    function updateEntranceInfo() {
      const infoElement = document.getElementById('entranceInfo');

      if (state.entrances.length === 0) {
        infoElement.textContent = 'æœªè¨­å®šå‡ºå…¥å£';
        return;
      }

      let infoHTML = `<strong>å·²è¨­å®š ${state.entrances.length} å€‹å‡ºå…¥å£ï¼š</strong><br>`;
      state.entrances.forEach((entrance, index) => {
        const xM = (entrance.x / state.scale).toFixed(1);
        const yM = (entrance.y / state.scale).toFixed(1);
        infoHTML += `${index + 1}. ä½ç½®: (${xM}, ${yM}) m<br>`;
      });

      infoElement.innerHTML = infoHTML;
    }

    // ========== ç‰©ä»¶ç®¡ç†åŠŸèƒ½ ==========
    function refreshItemsUI() {
      const container = document.getElementById('itemsContainer');
      container.innerHTML = '';

      if (state.itemsPool.length === 0) {
        container.innerHTML = '<div class="muted" style="padding:20px;text-align:center;">æš«ç„¡å¾…æ’ç‰©ä»¶</div>';
        return;
      }

      state.itemsPool.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'list-item';

        // æ ¹æ“šç‰©ä»¶é¡å‹è¨­å®šé¡è‰²
        const typeColor = getTypeColor(item.type);
        const icon = item.icon || getDefaultIcon(item.type);

        div.innerHTML = `
      <div style="display:flex;gap:10px;align-items:center">
        <div style="font-size:24px;color:${typeColor}">${icon}</div>
        <div>
          <strong>${item.customName || getTypeLabel(item.type)}</strong>
          <div class="muted" style="font-size:12px">
            ${item.count} å€‹ | ${item.w} Ã— ${item.h} å…¬å°º
            ${item.customName ? `<br>é¡å‹: ${getTypeLabel(item.type)}` : ''}
          </div>
        </div>
      </div>
      <div style="display:flex;gap:6px;align-items:center">
        <button data-index="${index}" class="small placeOne" title="æ”¾ç½®ä¸€å€‹">ğŸ“</button>
        <button data-index="${index}" class="small remove" title="åˆªé™¤">ğŸ—‘ï¸</button>
      </div>
    `;

        container.appendChild(div);
      });

      // ç¶å®šæŒ‰éˆ•äº‹ä»¶
      container.querySelectorAll('.placeOne').forEach(button => {
        button.addEventListener('click', () => {
          const index = parseInt(button.getAttribute('data-index'));
          placeOneFromPool(index);
        });
      });

      container.querySelectorAll('.remove').forEach(button => {
        button.addEventListener('click', () => {
          const index = parseInt(button.getAttribute('data-index'));
          state.itemsPool.splice(index, 1);
          refreshItemsUI();
        });
      });
    }

    // ========== ç‰©ä»¶é¡å‹è¼”åŠ©å‡½æ•¸ ==========
    function getTypeLabel(type) {
      const typeMap = {
        personal_tent: 'å€‹äººå¸³ç¯·',
        group_tent: 'åœ˜é«”å¸³ç¯·',
        table: 'æŠ˜ç–Šæ¡Œ',
        toilet: 'ç§»å‹•å»æ‰€',
        kitchen: 'ç‚Šäº‹å€',
        command: 'æŒ‡æ®ä¸­å¿ƒ',
        storage: 'è£å‚™å„²å­˜å€',
        medical: 'é†«ç™‚å¸³ç¯·',
        power: 'ç™¼é›»æ©Ÿ/é›»æº',
        water: 'é£²æ°´ç«™',
        shower: 'æ·‹æµ´é–“',
        waste: 'å»¢æ£„ç‰©å€'
      };

      return typeMap[type] || type;
    }

    function getDefaultIcon(type) {
      const iconMap = {
        personal_tent: 'â›º',
        group_tent: 'â›º',
        table: 'ğŸ›‹ï¸',
        toilet: 'ğŸš»',
        kitchen: 'ğŸ”¥',
        command: 'ğŸ¯',
        storage: 'ğŸ“¦',
        medical: 'ğŸ¥',
        power: 'ğŸ”Œ',
        water: 'ğŸ’§',
        shower: 'ğŸš¿',
        waste: 'ğŸ—‘ï¸'
      };

      return iconMap[type] || 'ğŸ“¦';
    }

    function getTypeColor(type) {
      const colorMap = {
        personal_tent: '#10b981',
        group_tent: '#3b82f6',
        table: '#f59e0b',
        toilet: '#8b5cf6',
        kitchen: '#ef4444',
        command: '#f97316',
        storage: '#6366f1',
        medical: '#ec4899',
        power: '#84cc16',
        water: '#06b6d4',
        shower: '#0ea5e9',
        waste: '#64748b'
      };

      return colorMap[type] || '#9fb6b0';
    }

    // ========== æ”¾ç½®å–®ä¸€ç‰©ä»¶ ==========
    function placeOneFromPool(index) {
      if (!state.polygonClosed) {
        alert('è«‹å…ˆå®Œæˆå ´åœ°ç¯„åœå®šç¾©');
        return;
      }

      const item = state.itemsPool[index];
      if (item.count <= 0) return;

      // æ‰¾åˆ°ç©ºä½æ”¾ç½®ç‰©ä»¶
      const pxW = item.w * state.scale;
      const pxH = item.h * state.scale;
      const centroid = calculatePolygonCentroid(state.polygon);

      let position = findFreeSpot(pxW, pxH, centroid.x, centroid.y);

      if (!position) {
        // å˜—è©¦åœ¨å ´åœ°å…§éš¨æ©Ÿå°‹æ‰¾ä½ç½®
        position = findRandomFreeSpot(pxW, pxH);
      }

      if (!position) {
        alert('æ‰¾ä¸åˆ°åˆé©çš„æ”¾ç½®ä½ç½®ï¼Œè«‹èª¿æ•´å ´åœ°å¤§å°æˆ–æ¸›å°‘ç‰©ä»¶');
        return;
      }

      // å»ºç«‹å·²æ”¾ç½®ç‰©ä»¶
      const placedItem = {
        id: `item_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: item.type,
        customName: item.customName || getTypeLabel(item.type),
        x: position.x,
        y: position.y,
        width: pxW,
        height: pxH,
        icon: item.icon || getDefaultIcon(item.type),
        color: getTypeColor(item.type),
        meta: {
          widthM: item.w,
          heightM: item.h,
          originalIndex: index
        }
      };

      state.placed.push(placedItem);
      item.count--;

      if (item.count <= 0) {
        state.itemsPool.splice(index, 1);
      }

      updatePlacedGraphics();
      refreshItemsUI();
    }

    // ========== æ›´æ–°å·²æ”¾ç½®ç‰©ä»¶åœ–å½¢ ==========
    function updatePlacedGraphics() {
      if (!state.placedGroup) return;

      state.placedGroup.innerHTML = '';
      const svgNS = 'http://www.w3.org/2000/svg';

      state.placed.forEach(item => {
        const group = document.createElementNS(svgNS, 'g');
        group.setAttribute('transform', `translate(${item.x}, ${item.y})`);
        group.setAttribute('data-id', item.id);
        group.style.cursor = 'move';

        // çŸ©å½¢é‚Šæ¡†
        const rect = document.createElementNS(svgNS, 'rect');
        rect.setAttribute('x', -item.width / 2);
        rect.setAttribute('y', -item.height / 2);
        rect.setAttribute('width', item.width);
        rect.setAttribute('height', item.height);
        rect.setAttribute('rx', 6);
        rect.setAttribute('ry', 6);
        rect.setAttribute('fill', `${item.color}20`); // 20 è¡¨ç¤º 12% é€æ˜åº¦
        rect.setAttribute('stroke', item.color);
        rect.setAttribute('stroke-width', 2);
        rect.setAttribute('class', 'placed-item');

        // åœ–ç¤º
        const text = document.createElementNS(svgNS, 'text');
        text.setAttribute('x', 0);
        text.setAttribute('y', 0);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('dominant-baseline', 'middle');
        text.setAttribute('font-size', Math.max(16, Math.min(30, item.width / 4)));
        text.setAttribute('fill', item.color);
        text.textContent = item.icon;

        // åç¨±æ¨™ç±¤
        const label = document.createElementNS(svgNS, 'text');
        label.setAttribute('x', 0);
        label.setAttribute('y', item.height / 2 + 16);
        label.setAttribute('text-anchor', 'middle');
        label.setAttribute('font-size', 12);
        label.setAttribute('fill', '#bfeee0');
        label.textContent = item.customName;

        // å°ºå¯¸æ¨™ç±¤
        const sizeLabel = document.createElementNS(svgNS, 'text');
        sizeLabel.setAttribute('x', 0);
        sizeLabel.setAttribute('y', item.height / 2 + 30);
        sizeLabel.setAttribute('text-anchor', 'middle');
        sizeLabel.setAttribute('font-size', 10);
        sizeLabel.setAttribute('fill', '#9fb6b0');
        sizeLabel.textContent = `${item.meta.widthM} Ã— ${item.meta.heightM} m`;

        group.appendChild(rect);
        group.appendChild(text);
        group.appendChild(label);
        group.appendChild(sizeLabel);

        // é»æ“Šäº‹ä»¶ - é¸æ“‡ç‰©ä»¶
        group.addEventListener('click', (event) => {
          event.stopPropagation();
          if (state.currentMode === 'select') {
            selectItem(item);
          }
        });

        // é›™æ“Šäº‹ä»¶ - ç·¨è¼¯ç‰©ä»¶
        group.addEventListener('dblclick', (event) => {
          event.stopPropagation();
          openEditModal(item);
        });

        state.placedGroup.appendChild(group);
      });
      // ç¶å®šäº‹ä»¶
      bindPlacedItemEvents();
    }

    // ========== é¸æ“‡ç‰©ä»¶åŠŸèƒ½ ==========
    function selectItem(item) {
      // ç§»é™¤ä¹‹å‰é¸ä¸­çš„æ¨£å¼
      document.querySelectorAll('.placed-item').forEach(el => {
        el.setAttribute('stroke-width', 2);
      });

      // ç‚ºé¸ä¸­çš„ç‰©ä»¶æ·»åŠ æ¨£å¼
      const selectedElement = document.querySelector(`[data-id="${item.id}"] rect`);
      if (selectedElement) {
        selectedElement.setAttribute('stroke-width', 4);
        selectedElement.setAttribute('stroke', '#ffd700'); // é‡‘è‰²é‚Šæ¡†
      }

      state.selectedItem = item;
    }

    // ========== é–‹å•Ÿç·¨è¼¯æ¨¡æ…‹è¦–çª— ==========
    function openEditModal(item) {
      state.selectedItem = item;

      document.getElementById('editItemName').value = item.customName || getTypeLabel(item.type);
      document.getElementById('editItemWidth').value = item.meta.widthM;
      document.getElementById('editItemHeight').value = item.meta.heightM;
      document.getElementById('editItemIcon').value = item.icon;

      document.getElementById('editModal').style.display = 'block';
      document.getElementById('modalOverlay').style.display = 'block';
    }

    function closeEditModal() {
      document.getElementById('editModal').style.display = 'none';
      document.getElementById('modalOverlay').style.display = 'none';
      state.selectedItem = null;
    }

    // ========== å„²å­˜ç·¨è¼¯è®Šæ›´ ==========
    function saveItemEdit() {
      if (!state.selectedItem) return;

      const newName = document.getElementById('editItemName').value.trim();
      const newWidth = parseFloat(document.getElementById('editItemWidth').value);
      const newHeight = parseFloat(document.getElementById('editItemHeight').value);
      const newIcon = document.getElementById('editItemIcon').value;

      if (!newName) {
        alert('è«‹è¼¸å…¥ç‰©ä»¶åç¨±');
        return;
      }

      if (newWidth <= 0 || newHeight <= 0) {
        alert('è«‹è¼¸å…¥æœ‰æ•ˆçš„å°ºå¯¸');
        return;
      }

      // æ›´æ–°ç‰©ä»¶å±¬æ€§
      state.selectedItem.customName = newName;
      state.selectedItem.width = newWidth * state.scale;
      state.selectedItem.height = newHeight * state.scale;
      state.selectedItem.icon = newIcon;
      state.selectedItem.meta.widthM = newWidth;
      state.selectedItem.meta.heightM = newHeight;

      // ç¢ºä¿ç‰©ä»¶ä»åœ¨å ´åœ°å…§
      constrainItemToPolygon(state.selectedItem);

      updatePlacedGraphics();
      closeEditModal();
    }

    // ========== åˆªé™¤é¸ä¸­ç‰©ä»¶ ==========
    function deleteSelectedItem() {
      if (!state.selectedItem) return;

      if (confirm('ç¢ºå®šè¦åˆªé™¤æ­¤ç‰©ä»¶å—ï¼Ÿ')) {
        const index = state.placed.findIndex(item => item.id === state.selectedItem.id);
        if (index !== -1) {
          state.placed.splice(index, 1);
          updatePlacedGraphics();
        }
        closeEditModal();
      }
    }

    // ========== AI æ™ºèƒ½æ’ç‰ˆæ¼”ç®—æ³• ==========
    function autoArrange() {
      if (!state.polygonClosed) {
        alert('è«‹å…ˆå®Œæˆå ´åœ°ç¯„åœå®šç¾©');
        return;
      }

      // èª¿è©¦ï¼šé¡¯ç¤ºç•¶å‰ç‰©ä»¶æ± ç‹€æ…‹
      console.log('AIæ’ç‰ˆå‰ç‰©ä»¶æ± :', state.itemsPool);

      if (state.itemsPool.length === 0 && state.placed.length === 0) {
        alert('æ²’æœ‰ç‰©ä»¶éœ€è¦æ’åˆ—');
        return;
      }

      // æ¸…é™¤ç¾æœ‰æ’åˆ—ï¼ˆä½†ä¿ç•™æœªæ”¾ç½®çš„ç‰©ä»¶ï¼‰
      const tempPlaced = [...state.placed];
      state.placed = [];

      // æ”¶é›†æ‰€æœ‰éœ€è¦æ’åˆ—çš„ç‰©ä»¶
      let allItems = [];

      // 1. å…ˆåŠ å…¥å¾…æ’æ¸…å–®ä¸­çš„ç‰©ä»¶
      state.itemsPool.forEach(item => {
        console.log(`åŠ å…¥å¾…æ’ç‰©ä»¶: ${item.type} x ${item.count}`);
        for (let i = 0; i < item.count; i++) {
          allItems.push({
            type: item.type,
            customName: item.customName || getTypeLabel(item.type),
            width: item.w * state.scale,
            height: item.h * state.scale,
            icon: item.icon || getDefaultIcon(item.type),
            color: getTypeColor(item.type),
            meta: {
              widthM: item.w,
              heightM: item.h,
              originalIndex: allItems.length
            }
          });
        }
      });

      // 2. åŠ å…¥å·²æ”¾ç½®ä½†æœªåœ¨å¾…æ’æ¸…å–®ä¸­çš„ç‰©ä»¶
      tempPlaced.forEach(item => {
        // æª¢æŸ¥æ˜¯å¦å·²ç¶“åœ¨å¾…æ’æ¸…å–®ä¸­
        const alreadyInPool = state.itemsPool.some(poolItem =>
          poolItem.type === item.type &&
          poolItem.w === item.meta.widthM &&
          poolItem.h === item.meta.heightM
        );

        if (!alreadyInPool) {
          allItems.push({
            type: item.type,
            customName: item.customName,
            width: item.width,
            height: item.height,
            icon: item.icon,
            color: item.color,
            meta: {
              widthM: item.meta.widthM,
              heightM: item.meta.heightM,
              originalIndex: allItems.length
            }
          });
        }
      });

      // å¦‚æœæ²’æœ‰ç‰©ä»¶ï¼Œä½¿ç”¨é è¨­ç¯„ä¾‹
      if (allItems.length === 0) {
        console.log('ä½¿ç”¨ç¯„ä¾‹ç‰©ä»¶');
        allItems = getSampleItems();
      }

      console.log('ç¸½å…±éœ€è¦æ’åˆ—çš„ç‰©ä»¶æ•¸:', allItems.length);

      // æ ¹æ“šç­–ç•¥æ’åºç‰©ä»¶
      const strategy = document.getElementById('arrangeStrategy').value;
      sortItemsByStrategy(allItems, strategy);

      // å–å¾—æ’ç‰ˆåƒæ•¸
      const aisleWidth = parseFloat(document.getElementById('aisleWidth').value) * state.scale;
      const marginWidth = parseFloat(document.getElementById('marginWidth').value) * state.scale;

      // åŸ·è¡Œæ’ç‰ˆ
      const placedItems = performAutoArrange(allItems, strategy, aisleWidth, marginWidth);

      // èª¿è©¦ï¼šé¡¯ç¤ºæ’åˆ—çµæœ
      console.log('æ’åˆ—çµæœ:', placedItems.length, 'å€‹ç‰©ä»¶');

      // æ›´æ–°ç‹€æ…‹
      state.placed = placedItems;

      // æ¸…ç©ºå¾…æ’æ¸…å–®ï¼ˆä½¿ç”¨è€…å¯ä»¥é‡æ–°æ·»åŠ ï¼‰
      // state.itemsPool = []; // è¨»è§£æ‰é€™è¡Œï¼Œä¸æ¸…ç©ºå¾…æ’æ¸…å–®

      // æ›´æ–°é¡¯ç¤º
      updatePlacedGraphics();
      refreshItemsUI();

      // é‡æ–°ç¶å®šäº‹ä»¶
      setTimeout(() => {
        bindPlacedItemEvents();
      }, 100);

      alert(`AI æ’ç‰ˆå®Œæˆï¼æˆåŠŸæ’åˆ—äº† ${placedItems.length} å€‹ç‰©ä»¶ã€‚`);
    }
    // æ–°å¢å‡½æ•¸ï¼šé‡æ–°ç¶å®šå·²æ”¾ç½®ç‰©ä»¶çš„äº‹ä»¶
    function bindPlacedItemEvents() {
      const svgNS = 'http://www.w3.org/2000/svg';
      const placedGroups = state.placedGroup.querySelectorAll('g[data-id]');

      placedGroups.forEach(group => {
        const itemId = group.getAttribute('data-id');
        const item = state.placed.find(item => item.id === itemId);

        if (!item) return;

        // é‡æ–°ç¶å®šé»æ“Šäº‹ä»¶
        group.addEventListener('click', (event) => {
          event.stopPropagation();
          if (state.currentMode === 'select') {
            selectItem(item);
          }
        });

        // é‡æ–°ç¶å®šé›™æ“Šäº‹ä»¶
        group.addEventListener('dblclick', (event) => {
          event.stopPropagation();
          openEditModal(item);
        });
      });
    }

    // ========== æ ¹æ“šç­–ç•¥æ’åºç‰©ä»¶ ==========
    function sortItemsByStrategy(items, strategy) {
      switch (strategy) {
        case 'row':
          // è¡Œåˆ—å¼ï¼šå…ˆæ’å¤§çš„ï¼Œå†æ’å°çš„
          items.sort((a, b) => (b.width * b.height) - (a.width * a.height));
          break;

        case 'cluster':
          // åˆ†çµ„èšé›†ï¼šæŒ‰é¡å‹åˆ†çµ„
          items.sort((a, b) => a.type.localeCompare(b.type));
          break;

        case 'efficient':
          // ç©ºé–“æœ€å„ªåŒ–ï¼šæ··åˆæ’åº
          items.sort((a, b) => {
            const areaA = a.width * a.height;
            const areaB = b.width * b.height;
            return areaB - areaA || a.type.localeCompare(b.type);
          });
          break;

        case 'entrance':
          // å‡ºå…¥å£å„ªå…ˆï¼šé‡è¦ç‰©ä»¶é è¿‘å‡ºå…¥å£
          items.sort((a, b) => {
            const priorityA = getItemPriority(a.type);
            const priorityB = getItemPriority(b.type);
            return priorityB - priorityA;
          });
          break;
      }
    }

    // ========== ç²å–ç‰©ä»¶å„ªå…ˆç´š ==========
    function getItemPriority(type) {
      const priorityMap = {
        command: 10,     // æŒ‡æ®ä¸­å¿ƒæœ€é«˜å„ªå…ˆ
        medical: 9,      // é†«ç™‚æ¬¡ä¹‹
        kitchen: 8,      // ç‚Šäº‹å€
        toilet: 7,       // å»æ‰€
        water: 6,        // é£²æ°´ç«™
        shower: 5,       // æ·‹æµ´é–“
        power: 4,        // é›»æº
        group_tent: 3,   // åœ˜é«”å¸³ç¯·
        personal_tent: 2, // å€‹äººå¸³ç¯·
        storage: 1,      // è£å‚™å„²å­˜
        table: 1,        // æ¡Œå­
        waste: 0         // å»¢æ£„ç‰©å€
      };

      return priorityMap[type] || 0;
    }

    // ========== åŸ·è¡Œè‡ªå‹•æ’ç‰ˆ ==========
    function performAutoArrange(items, strategy, aisleWidth, marginWidth) {
      const placedItems = [];
      const bbox = calculatePolygonBoundingBox(state.polygon);

      // è€ƒæ…®é‚Šç•Œè·é›¢
      const innerBbox = {
        xmin: bbox.xmin + marginWidth,
        ymin: bbox.ymin + marginWidth,
        xmax: bbox.xmax - marginWidth,
        ymax: bbox.ymax - marginWidth
      };

      // æ ¹æ“šç­–ç•¥é¸æ“‡æ’ç‰ˆæ–¹æ³•
      switch (strategy) {
        case 'row':
          placedItems.push(...arrangeInRows(items, innerBbox, aisleWidth));
          break;

        case 'cluster':
          placedItems.push(...arrangeInClusters(items, innerBbox, aisleWidth));
          break;

        case 'efficient':
          placedItems.push(...arrangeEfficiently(items, innerBbox, aisleWidth));
          break;

        case 'entrance':
          placedItems.push(...arrangeByEntrances(items, innerBbox, aisleWidth));
          break;

        default:
          placedItems.push(...arrangeInRows(items, innerBbox, aisleWidth));
      }

      return placedItems;
    }

    // ========== è¡Œåˆ—å¼æ’åˆ— ==========
    function arrangeInRows(items, bbox, aisleWidth) {
      const placed = [];
      let currentX = bbox.xmin;
      let currentY = bbox.ymin;
      let maxHeightInRow = 0;
      let rowNumber = 0;

      for (const item of items) {
        // æª¢æŸ¥æ˜¯å¦è¶…å‡ºå³é‚Šç•Œ
        if (currentX + item.width > bbox.xmax) {
          // æ›è¡Œ
          currentY += maxHeightInRow + aisleWidth;
          currentX = bbox.xmin;
          maxHeightInRow = 0;
          rowNumber++;

          // æª¢æŸ¥æ˜¯å¦è¶…å‡ºä¸‹é‚Šç•Œ
          if (currentY + item.height > bbox.ymax) {
            console.warn('ç©ºé–“ä¸è¶³ï¼Œç„¡æ³•æ”¾ç½®æ‰€æœ‰ç‰©ä»¶');
            break;
          }
        }

        // è¨ˆç®—ç‰©ä»¶ä¸­å¿ƒä½ç½®
        const centerX = currentX + item.width / 2;
        const centerY = currentY + item.height / 2;

        // æª¢æŸ¥æ˜¯å¦åœ¨å ´åœ°å…§
        if (!isPointInPolygon(centerX, centerY, state.polygon)) {
          // å˜—è©¦å‘ä¸‹ç§»å‹•
          currentY += 10;
          currentX = bbox.xmin;
          maxHeightInRow = 0;
          continue;
        }

        // å»ºç«‹æ”¾ç½®ç‰©ä»¶
        const placedItem = {
          id: `auto_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          type: item.type,
          customName: item.customName,
          x: centerX,
          y: centerY,
          width: item.width,
          height: item.height,
          icon: item.icon,
          color: item.color,
          meta: item.meta
        };

        placed.push(placedItem);

        // æ›´æ–°ä½ç½®
        currentX += item.width + aisleWidth;
        maxHeightInRow = Math.max(maxHeightInRow, item.height);
      }

      return placed;
    }

    // ========== åˆ†çµ„èšé›†æ’åˆ— ==========
    function arrangeInClusters(items, bbox, aisleWidth) {
      // æŒ‰é¡å‹åˆ†çµ„
      const groups = {};
      items.forEach(item => {
        if (!groups[item.type]) {
          groups[item.type] = [];
        }
        groups[item.type].push(item);
      });

      const placed = [];
      let currentX = bbox.xmin;
      let currentY = bbox.ymin;
      let clusterHeight = 0;

      // å°æ¯ç¨®é¡å‹é€²è¡Œæ’åˆ—
      for (const type in groups) {
        const typeItems = groups[type];
        let typeWidth = 0;
        let typeHeight = 0;

        // è¨ˆç®—æ­¤é¡å‹éœ€è¦çš„ç©ºé–“
        typeItems.forEach(item => {
          typeWidth = Math.max(typeWidth, item.width);
          typeHeight += item.height + aisleWidth;
        });

        typeHeight -= aisleWidth; // ç§»é™¤æœ€å¾Œä¸€å€‹é–“è·

        // æª¢æŸ¥æ˜¯å¦éœ€è¦æ›è¡Œ
        if (currentX + typeWidth > bbox.xmax) {
          currentX = bbox.xmin;
          currentY += clusterHeight + aisleWidth * 2;
          clusterHeight = 0;
        }

        // æ”¾ç½®æ­¤é¡å‹çš„æ‰€æœ‰ç‰©ä»¶
        let itemY = currentY;
        for (const item of typeItems) {
          const centerX = currentX + item.width / 2;
          const centerY = itemY + item.height / 2;

          if (isPointInPolygon(centerX, centerY, state.polygon)) {
            const placedItem = {
              id: `auto_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              type: item.type,
              customName: item.customName,
              x: centerX,
              y: centerY,
              width: item.width,
              height: item.height,
              icon: item.icon,
              color: item.color,
              meta: item.meta
            };

            placed.push(placedItem);
            itemY += item.height + aisleWidth;
            clusterHeight = Math.max(clusterHeight, itemY - currentY);
          }
        }

        currentX += typeWidth + aisleWidth * 2;
      }

      return placed;
    }

    // ========== å‡ºå…¥å£å„ªå…ˆæ’åˆ— ==========
    function arrangeByEntrances(items, bbox, aisleWidth) {
      const placed = [];

      if (state.entrances.length === 0) {
        // æ²’æœ‰å‡ºå…¥å£ï¼Œä½¿ç”¨é è¨­æ’åˆ—
        return arrangeInRows(items, bbox, aisleWidth);
      }

      // å–å¾—ä¸»è¦å‡ºå…¥å£
      const mainEntrance = state.entrances[0];

      // æŒ‰å„ªå…ˆç´šæ’åº
      const prioritizedItems = [...items].sort((a, b) => {
        return getItemPriority(b.type) - getItemPriority(a.type);
      });

      // å¾å‡ºå…¥å£é–‹å§‹å‘å¤–æ’åˆ—
      let startX = mainEntrance.x;
      let startY = mainEntrance.y;
      let direction = 0; // 0: å‘å³, 1: å‘ä¸‹, 2: å‘å·¦, 3: å‘ä¸Š

      for (const item of prioritizedItems) {
        let position = null;
        let attempts = 0;

        // å˜—è©¦åœ¨ä¸åŒæ–¹å‘å°‹æ‰¾ä½ç½®
        while (!position && attempts < 50) {
          const angle = (direction * Math.PI / 2) + (attempts * 0.1);
          const radius = 50 + attempts * 20;

          const testX = startX + Math.cos(angle) * radius;
          const testY = startY + Math.sin(angle) * radius;

          position = findFreeSpotForItem(item, testX, testY, placed, bbox, null);
          attempts++;
        }

        if (position) {
          const placedItem = {
            id: `auto_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            type: item.type,
            customName: item.customName,
            x: position.x,
            y: position.y,
            width: item.width,
            height: item.height,
            icon: item.icon,
            color: item.color,
            meta: item.meta
          };

          placed.push(placedItem);
          direction = (direction + 1) % 4; // æ”¹è®Šæ–¹å‘
        }
      }

      return placed;
    }

    // ========== è¼”åŠ©å‡½æ•¸ ==========
    // è¨ˆç®—å¤šé‚Šå½¢é‡å¿ƒ
    function calculatePolygonCentroid(points) {
      let area = 0;
      let centroidX = 0;
      let centroidY = 0;
      const n = points.length;

      for (let i = 0; i < n; i++) {
        const [x1, y1] = points[i];
        const [x2, y2] = points[(i + 1) % n];
        const cross = x1 * y2 - x2 * y1;

        area += cross;
        centroidX += (x1 + x2) * cross;
        centroidY += (y1 + y2) * cross;
      }

      area /= 2;
      centroidX /= 6 * area;
      centroidY /= 6 * area;

      return { x: centroidX || 600, y: centroidY || 350 };
    }

    // è¨ˆç®—å¤šé‚Šå½¢é‚Šç•Œæ¡†
    function calculatePolygonBoundingBox(points) {
      let xmin = Infinity, ymin = Infinity;
      let xmax = -Infinity, ymax = -Infinity;

      for (const [x, y] of points) {
        xmin = Math.min(xmin, x);
        ymin = Math.min(ymin, y);
        xmax = Math.max(xmax, x);
        ymax = Math.max(ymax, y);
      }

      return { xmin, ymin, xmax, ymax };
    }

    // æª¢æŸ¥é»æ˜¯å¦åœ¨å¤šé‚Šå½¢å…§
    function isPointInPolygon(x, y, polygon) {
      let inside = false;
      const n = polygon.length;

      for (let i = 0, j = n - 1; i < n; j = i++) {
        const [xi, yi] = polygon[i];
        const [xj, yj] = polygon[j];

        const intersect = ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

        if (intersect) inside = !inside;
      }

      return inside;
    }

    // æª¢æŸ¥çŸ©å½¢æ˜¯å¦å®Œå…¨åœ¨å¤šé‚Šå½¢å…§
    function isRectInPolygon(x, y, width, height, polygon) {
      // æª¢æŸ¥å››å€‹è§’é»
      const corners = [
        [x - width / 2, y - height / 2],
        [x + width / 2, y - height / 2],
        [x + width / 2, y + height / 2],
        [x - width / 2, y + height / 2]
      ];

      return corners.every(corner =>
        isPointInPolygon(corner[0], corner[1], polygon)
      );
    }

    // æª¢æŸ¥æ˜¯å¦èˆ‡å…¶ä»–ç‰©ä»¶ç¢°æ’
    function checkCollision(x, y, width, height, placedItems, excludeId = null) {
      for (const item of placedItems) {
        if (excludeId && item.id === excludeId) continue;

        const dx = Math.abs(x - item.x);
        const dy = Math.abs(y - item.y);

        if (dx < (width / 2 + item.width / 2) &&
          dy < (height / 2 + item.height / 2)) {
          return true;
        }
      }

      return false;
    }

    // å°‹æ‰¾ç©ºä½æ”¾ç½®ç‰©ä»¶
    function findFreeSpotForItem(item, startX, startY, placedItems, bbox) {
      const maxAttempts = 100;
      const step = 10;

      // èºæ—‹æœç´¢
      for (let radius = 0; radius < 500; radius += step) {
        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
          const x = startX + radius * Math.cos(angle);
          const y = startY + radius * Math.sin(angle);

          // æª¢æŸ¥æ˜¯å¦åœ¨é‚Šç•Œæ¡†å…§
          if (x < bbox.xmin || x > bbox.xmax || y < bbox.ymin || y > bbox.ymax) {
            continue;
          }

          // æª¢æŸ¥æ˜¯å¦åœ¨å¤šé‚Šå½¢å…§ä¸”ç„¡ç¢°æ’
          if (isRectInPolygon(x, y, item.width, item.height, state.polygon) &&
            !checkCollision(x, y, item.width, item.height, placedItems)) {
            return { x, y };
          }
        }
      }

      return null;
    }

    // éš¨æ©Ÿå°‹æ‰¾ç©ºä½
    function findRandomFreeSpot(width, height) {
      const bbox = calculatePolygonBoundingBox(state.polygon);
      const maxAttempts = 500;

      for (let i = 0; i < maxAttempts; i++) {
        const x = bbox.xmin + Math.random() * (bbox.xmax - bbox.xmin);
        const y = bbox.ymin + Math.random() * (bbox.ymax - bbox.ymin);

        if (isRectInPolygon(x, y, width, height, state.polygon) &&
          !checkCollision(x, y, width, height, state.placed)) {
          return { x, y };
        }
      }

      return null;
    }

    // å°‹æ‰¾ç©ºä½ï¼ˆèˆŠç‰ˆå…¼å®¹ï¼‰
    function findFreeSpot(width, height, startX, startY) {
      return findFreeSpotForItem(
        { width, height },
        startX, startY,
        state.placed,
        calculatePolygonBoundingBox(state.polygon)
      );
    }

    // ç¢ºä¿ç‰©ä»¶åœ¨å ´åœ°å…§
    function constrainItemToPolygon(item) {
      const bbox = calculatePolygonBoundingBox(state.polygon);
      const margin = item.width / 2;

      // é™åˆ¶åœ¨é‚Šç•Œæ¡†å…§
      item.x = Math.max(bbox.xmin + margin, Math.min(bbox.xmax - margin, item.x));
      item.y = Math.max(bbox.ymin + margin, Math.min(bbox.ymax - margin, item.y));

      // ç¢ºä¿åœ¨å¤šé‚Šå½¢å…§
      if (!isRectInPolygon(item.x, item.y, item.width, item.height, state.polygon)) {
        // å¦‚æœä¸åœ¨å¤šé‚Šå½¢å…§ï¼Œå˜—è©¦æ‰¾åˆ°æœ€è¿‘çš„æœ‰æ•ˆä½ç½®
        const newPosition = findFreeSpotForItem(
          item, item.x, item.y, state.placed, bbox
        );

        if (newPosition) {
          item.x = newPosition.x;
          item.y = newPosition.y;
        }
      }
    }

    // é»æ“Šæ¸¬è©¦
    function hitTestPlaced(x, y) {
      for (let i = state.placed.length - 1; i >= 0; i--) {
        const item = state.placed[i];
        const dx = Math.abs(x - item.x);
        const dy = Math.abs(y - item.y);

        if (dx < item.width / 2 && dy < item.height / 2) {
          return item;
        }
      }

      return null;
    }

    // ========== åŒ¯å…¥ AI å»ºè­°ä½ˆå±€ ==========
    function importAILayout() {
      if (!state.polygonClosed) {
        alert('è«‹å…ˆå®Œæˆå ´åœ°ç¯„åœå®šç¾©');
        return;
      }

      // æ¸…é™¤ç¾æœ‰ç‰©ä»¶
      state.placed = [];
      state.itemsPool = [];

      // åŠ å…¥ç¯„ä¾‹ä½ˆå±€
      const sampleItems = getSampleLayout();

      sampleItems.forEach(item => {
        state.itemsPool.push({
          type: item.type,
          w: item.meta.widthM,
          h: item.meta.heightM,
          count: 1,
          icon: item.icon,
          customName: item.customName
        });
      });

      // è‡ªå‹•æ’åˆ—
      autoArrange();

      // ç¢ºä¿åˆ‡æ›åˆ°é¸æ“‡æ¨¡å¼
      setMode('select');

      alert('å·²åŒ¯å…¥ AI å»ºè­°ä½ˆå±€ç¯„æœ¬');
    }
    // ========== ç¯„ä¾‹ä½ˆå±€ ==========
    function getSampleLayout() {
      return [
        {
          type: 'command',
          customName: 'æŒ‡æ®ä¸­å¿ƒ',
          width: 4 * state.scale,
          height: 3 * state.scale,
          icon: 'ğŸ¯',
          color: getTypeColor('command'),
          meta: { widthM: 4, heightM: 3 }
        },
        {
          type: 'medical',
          customName: 'é†«ç™‚å¸³ç¯·',
          width: 3 * state.scale,
          height: 3 * state.scale,
          icon: 'ğŸ¥',
          color: getTypeColor('medical'),
          meta: { widthM: 3, heightM: 3 }
        },
        {
          type: 'kitchen',
          customName: 'ç‚Šäº‹å€',
          width: 4 * state.scale,
          height: 3 * state.scale,
          icon: 'ğŸ”¥',
          color: getTypeColor('kitchen'),
          meta: { widthM: 4, heightM: 3 }
        },
        {
          type: 'group_tent',
          customName: 'ç”·ç”Ÿåœ˜é«”å¸³',
          width: 5 * state.scale,
          height: 4 * state.scale,
          icon: 'â›º',
          color: getTypeColor('group_tent'),
          meta: { widthM: 5, heightM: 4 }
        },
        {
          type: 'group_tent',
          customName: 'å¥³ç”Ÿåœ˜é«”å¸³',
          width: 5 * state.scale,
          height: 4 * state.scale,
          icon: 'â›º',
          color: getTypeColor('group_tent'),
          meta: { widthM: 5, heightM: 4 }
        },
        {
          type: 'personal_tent',
          customName: 'å€‹äººå¸³ç¯· A',
          width: 2 * state.scale,
          height: 2 * state.scale,
          icon: 'â›º',
          color: getTypeColor('personal_tent'),
          meta: { widthM: 2, heightM: 2 }
        },
        {
          type: 'personal_tent',
          customName: 'å€‹äººå¸³ç¯· B',
          width: 2 * state.scale,
          height: 2 * state.scale,
          icon: 'â›º',
          color: getTypeColor('personal_tent'),
          meta: { widthM: 2, heightM: 2 }
        },
        {
          type: 'storage',
          customName: 'è£å‚™å„²å­˜å€',
          width: 3 * state.scale,
          height: 2 * state.scale,
          icon: 'ğŸ“¦',
          color: getTypeColor('storage'),
          meta: { widthM: 3, heightM: 2 }
        },
        {
          type: 'toilet',
          customName: 'ç§»å‹•å»æ‰€',
          width: 1.2 * state.scale,
          height: 1.2 * state.scale,
          icon: 'ğŸš»',
          color: getTypeColor('toilet'),
          meta: { widthM: 1.2, heightM: 1.2 }
        },
        {
          type: 'water',
          customName: 'é£²æ°´ç«™',
          width: 1.5 * state.scale,
          height: 1.5 * state.scale,
          icon: 'ğŸ’§',
          color: getTypeColor('water'),
          meta: { widthM: 1.5, heightM: 1.5 }
        }
      ];
    }

    function getSampleItems() {
      return [
        {
          type: 'personal_tent',
          customName: 'å¸³ç¯·',
          width: 2 * state.scale,
          height: 2 * state.scale,
          icon: 'â›º',
          color: getTypeColor('personal_tent'),
          meta: { widthM: 2, heightM: 2 }
        },
        {
          type: 'table',
          customName: 'æŠ˜ç–Šæ¡Œ',
          width: 2 * state.scale,
          height: 1 * state.scale,
          icon: 'ğŸ›‹ï¸',
          color: getTypeColor('table'),
          meta: { widthM: 2, heightM: 1 }
        }
      ];
    }

    // ========== åŒ¯å‡ºåŠŸèƒ½ ==========
    function exportPNG() {
      const svgElement = state.svgRoot;
      if (!svgElement) return;

      // å…‹éš† SVG ä»¥é¿å…ä¿®æ”¹åŸå§‹å…ƒç´ 
      const clonedSvg = svgElement.cloneNode(true);

      // ç§»é™¤äº¤äº’å…ƒç´ å’Œä¸´æ—¶å›¾å½¢
      const toRemove = clonedSvg.querySelectorAll('.handle, .entrance-marker');
      toRemove.forEach(el => el.remove());

      // è®¾ç½®æ˜ç¡®çš„å°ºå¯¸
      const svgData = new XMLSerializer().serializeToString(clonedSvg);
      const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(svgBlob);

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();

      // è®¾ç½® canvas å°ºå¯¸ä¸º SVG çš„å®é™…å°ºå¯¸
      canvas.width = 1920;
      canvas.height = 1080;

      img.onload = function () {
        // ç»˜åˆ¶èƒŒæ™¯
        ctx.fillStyle = '#071425';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // å±…ä¸­ç»˜åˆ¶ SVG
        const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
        const x = (canvas.width - img.width * scale) / 2;
        const y = (canvas.height - img.height * scale) / 2;

        ctx.drawImage(img, x, y, img.width * scale, img.height * scale);

        // æ·»åŠ æ ‡é¢˜å’Œå…ƒæ•°æ®
        ctx.fillStyle = '#e6eef2';
        ctx.font = 'bold 24px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('BoO ç°åœºå¸ƒå±€å›¾', canvas.width / 2, 40);

        ctx.font = '16px system-ui, sans-serif';
        ctx.fillText(`ç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString('zh-TW')}`, canvas.width / 2, 70);

        if (state.polygonClosed) {
          const areaPx = calculatePolygonArea(state.polygon);
          const areaM2 = (areaPx / (state.scale * state.scale)).toFixed(2);
          ctx.fillText(`åœºåœ°é¢ç§¯: ${areaM2} å¹³æ–¹å…¬å°º`, canvas.width / 2, 100);
        }

        // è½¬æ¢ä¸º PNG å¹¶ä¸‹è½½
        canvas.toBlob(function (blob) {
          const pngUrl = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = pngUrl;
          a.download = `boo_layout_${Date.now()}.png`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(pngUrl);
        }, 'image/png');

        URL.revokeObjectURL(url);
      };

      img.onerror = function () {
        console.error('å›¾ç‰‡åŠ è½½å¤±è´¥');
        alert('å¯¼å‡ºPNGæ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•');
        URL.revokeObjectURL(url);
      };

      img.src = url;
    }
    function downloadJSON() {
      const data = {
        project: 'BoO ç¾å ´ä½ˆå±€',
        version: '2.0',
        timestamp: new Date().toISOString(),
        scale: state.scale,
        polygon: state.polygon,
        entrances: state.entrances,
        placed: state.placed.map(item => ({
          type: item.type,
          customName: item.customName,
          x: item.x,
          y: item.y,
          width: item.width,
          height: item.height,
          icon: item.icon,
          meta: item.meta
        })),
        itemsPool: state.itemsPool
      };

      const jsonString = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `boo_layout_${new Date().getTime()}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      URL.revokeObjectURL(url);
    }

    // ========== è¨­å®šæ¨¡å¼ ==========
    function setMode(mode) {
      state.currentMode = mode;

      // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-mode') === mode) {
          btn.classList.add('active');
        }
      });

      // æ›´æ–°æ¨™ç±¤
      const modeLabels = {
        draw: 'ç¹ªè£½å ´åœ°',
        entrance: 'è¨­å®šå‡ºå…¥å£',
        select: 'é¸æ“‡/ç·¨è¼¯ç‰©ä»¶'
      };

      document.getElementById('modeLabel').textContent = modeLabels[mode] || mode;

      // æ›´æ–° SVG æ¸¸æ¨™
      if (state.svgRoot) {
        const cursors = {
          draw: 'crosshair',
          entrance: 'cell',
          select: 'default'
        };
        state.svgRoot.style.cursor = cursors[mode] || 'default';
      }
    }

    // ========== åˆå§‹åŒ–äº‹ä»¶ç¶å®š ==========
    function initEventBindings() {
      // æ¨¡å¼é¸æ“‡
      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          setMode(btn.getAttribute('data-mode'));
        });
      });

      // æ¨™ç±¤é åˆ‡æ›
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.addEventListener('click', () => {
          const tabId = btn.getAttribute('data-tab');

          // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
          document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');

          // æ›´æ–°å…§å®¹é¡¯ç¤º
          document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
          });
          document.getElementById(`tab-${tabId}`).classList.add('active');
        });
      });

      // å ´åœ°è¨­å®š
      document.getElementById('scale').addEventListener('change', (e) => {
        state.scale = parseFloat(e.target.value) || 10;
        createSvg();
        updatePlacedGraphics();
        updateEntranceGraphics();
      });

      document.getElementById('clearBtn').addEventListener('click', () => {
        state.polygon = [];
        state.polygonClosed = false;
        state.placed = [];
        state.entrances = [];
        state.itemsPool = [];

        renderPolygon();
        updatePlacedGraphics();
        updateEntranceGraphics();
        refreshItemsUI();

        setMode('draw');
        document.getElementById('areaInfo').textContent = 'å ´åœ°å·²æ¸…é™¤';
      });

      document.getElementById('completeBtn').addEventListener('click', () => {
        if (state.polygon.length >= 3) {
          state.polygonClosed = true;
          renderPolygon();
          setMode('select');
          showAreaInfo();
        } else {
          alert('è‡³å°‘éœ€è¦ 3 å€‹é»ä¾†å®šç¾©å ´åœ°ç¯„åœ');
        }
      });

      document.getElementById('areaBtn').addEventListener('click', showAreaInfo);

      // å‡ºå…¥å£ç®¡ç†
      document.getElementById('addEntranceBtn').addEventListener('click', () => {
        setMode('entrance');
      });

      document.getElementById('clearEntranceBtn').addEventListener('click', () => {
        state.entrances = [];
        updateEntranceGraphics();
        updateEntranceInfo();
      });

      // ç‰©ä»¶ç®¡ç†
      document.getElementById('addItemBtn').addEventListener('click', () => {
        const type = document.getElementById('itemType').value;
        const width = parseFloat(document.getElementById('itemW').value) || 2;
        const height = parseFloat(document.getElementById('itemH').value) || 2;
        const count = parseInt(document.getElementById('itemCount').value) || 1;
        const iconSelect = document.getElementById('iconSel').value;
        const customName = document.getElementById('customName').value.trim();

        // åœ–ç¤ºæ˜ å°„
        const iconMap = {
          tent: 'â›º',
          toilet: 'ğŸš»',
          table: 'ğŸ›‹ï¸',
          fire: 'ğŸ”¥',
          flag: 'ğŸ¯',
          box: 'ğŸ“¦',
          med: 'ğŸ¥',
          power: 'ğŸ”Œ',
          water: 'ğŸ’§',
          shower: 'ğŸš¿',
          trash: 'ğŸ—‘ï¸'
        };

        const icon = iconMap[iconSelect] || 'ğŸ“¦';

        // åŠ å…¥ç‰©ä»¶æ¸…å–®
        state.itemsPool.push({
          type: type,
          w: width,
          h: height,
          count: count,
          icon: icon,
          customName: customName || getTypeLabel(type)
        });

        // æ¸…ç©ºè¼¸å…¥æ¬„ä½
        document.getElementById('customName').value = '';

        // æ›´æ–°é¡¯ç¤º
        refreshItemsUI();
      });

      // AI æ’ç‰ˆ
      document.getElementById('autoBtn').addEventListener('click', autoArrange);
      document.getElementById('importLayoutBtn').addEventListener('click', importAILayout);

      // åŒ¯å‡ºåŠŸèƒ½
      document.getElementById('exportPNG').addEventListener('click', exportPNG);
      document.getElementById('downloadJSON').addEventListener('click', downloadJSON);
      document.getElementById('clearPlaced').addEventListener('click', () => {
        state.placed = [];
        updatePlacedGraphics();
      });

      // ç·¨è¼¯æ¨¡æ…‹è¦–çª—
      document.getElementById('closeEditModal').addEventListener('click', closeEditModal);
      document.getElementById('modalOverlay').addEventListener('click', closeEditModal);
      document.getElementById('saveEditBtn').addEventListener('click', saveItemEdit);
      document.getElementById('deleteItemBtn').addEventListener('click', deleteSelectedItem);

      // ç¸®æ”¾æ§åˆ¶
      document.getElementById('zoomInBtn').addEventListener('click', () => {
        state.zoom = Math.min(3, state.zoom * 1.2);
        updateViewTransform();
      });

      document.getElementById('zoomOutBtn').addEventListener('click', () => {
        state.zoom = Math.max(0.5, state.zoom / 1.2);
        updateViewTransform();
      });

      document.getElementById('resetZoomBtn').addEventListener('click', () => {
        state.zoom = 1;
        state.pan = { x: 0, y: 0 };
        updateViewTransform();
      });

      // åœ¨ initEventBindings å‡½æ•¸ä¸­ï¼Œç‚ºç½®ä¸­è¦–åœ–æŒ‰éˆ•æ·»åŠ ä¿®æ­£
      document.getElementById('centerViewBtn').addEventListener('click', () => {
        if (state.polygonClosed && state.polygon.length > 0) {
          const centroid = calculatePolygonCentroid(state.polygon);

          // å°‡å ´åœ°ä¸­å¿ƒé»ç½®ä¸­é¡¯ç¤º
          const viewportCenterX = 600;  // 1200/2
          const viewportCenterY = 350;  // 700/2

          // è¨ˆç®—éœ€è¦çš„å¹³ç§»
          // viewportCenter = pan + centroid * zoom
          // æ‰€ä»¥ï¼špan = viewportCenter - centroid * zoom
          state.pan.x = viewportCenterX - centroid.x * state.zoom;
          state.pan.y = viewportCenterY - centroid.y * state.zoom;

          updateViewTransform();
        } else {
          // é‡ç½®åˆ°åˆå§‹ç‹€æ…‹
          state.zoom = 1;
          state.pan = { x: 0, y: 0 };
          updateViewTransform();
        }
      });


      // è¡Œå‹•è£ç½®å·¥å…·åˆ—
      document.getElementById('mobileDrawBtn').addEventListener('click', () => setMode('draw'));
      document.getElementById('mobileSelectBtn').addEventListener('click', () => setMode('select'));
      document.getElementById('mobileZoomIn').addEventListener('click', () => {
        state.zoom = Math.min(3, state.zoom * 1.2);
        updateViewTransform();
      });

      document.getElementById('mobileZoomOut').addEventListener('click', () => {
        state.zoom = Math.max(0.5, state.zoom / 1.2);
        updateViewTransform();
      });

      document.getElementById('mobileAutoArrange').addEventListener('click', autoArrange);

      // éµç›¤å¿«æ·éµ
      document.addEventListener('keydown', (e) => {
        // é˜²æ­¢åœ¨è¼¸å…¥æ¡†ä¸­çš„å¿«æ·éµ
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
          return;
        }

        switch (e.key) {
          case 'Escape':
            closeEditModal();
            break;
          case 'Delete':
            if (state.selectedItem) {
              const index = state.placed.findIndex(item => item.id === state.selectedItem.id);
              if (index !== -1) {
                state.placed.splice(index, 1);
                updatePlacedGraphics();
                state.selectedItem = null;
              }
            }
            break;
          case '+':
          case '=':
            if (e.ctrlKey) {
              state.zoom = Math.min(3, state.zoom * 1.2);
              updateViewTransform();
            }
            break;
          case '-':
            if (e.ctrlKey) {
              state.zoom = Math.max(0.5, state.zoom / 1.2);
              updateViewTransform();
            }
            break;
          case '0':
            if (e.ctrlKey) {
              state.zoom = 1;
              state.pan = { x: 0, y: 0 };
              updateViewTransform();
            }
            break;
        }
      });
    }

    // ========== åˆå§‹åŒ–æ‡‰ç”¨ç¨‹å¼ ==========
    // åœ¨ initApp å‡½æ•¸ä¸­ï¼Œç¢ºä¿åˆå§‹ç‹€æ…‹æ­£ç¢º
    function initApp() {
      // å»ºç«‹ SVG
      createSvg();

      // åˆå§‹åŒ–äº‹ä»¶ç¶å®š
      initEventBindings();

      // é‡ç½®ç‹€æ…‹
      state.zoom = 1;
      state.pan = { x: 0, y: 0 };  // ç¢ºä¿åˆå§‹å¹³ç§»ç‚º0
      updateViewTransform();

      // æ›´æ–°é¡¯ç¤º
      updatePlacedGraphics();
      refreshItemsUI();
      updateEntranceInfo();

      // è¨­å®šåˆå§‹æ¨¡å¼
      setMode('draw');
      // æ·»åŠ èª¿è©¦æŒ‰éˆ•
      const debugBtn = document.createElement('button');
      debugBtn.textContent = 'æŸ¥çœ‹ç‹€æ…‹';
      debugBtn.className = 'small';
      debugBtn.style.position = 'absolute';
      debugBtn.style.top = '50px';
      debugBtn.style.right = '10px';
      debugBtn.style.zIndex = '1000';
      debugBtn.onclick = function () {
        alert(`ç•¶å‰ç‹€æ…‹ï¼š
    ç¸®æ”¾ï¼š${state.zoom}
    å¹³ç§»ï¼šx=${state.pan.x.toFixed(2)}, y=${state.pan.y.toFixed(2)}
    æ¯”ä¾‹å°ºï¼š${state.scale} px/m
    å ´åœ°é ‚é»æ•¸ï¼š${state.polygon.length}
    å ´åœ°æ˜¯å¦å°é–‰ï¼š${state.polygonClosed}`);
      };

      // æ·»åŠ é‡ç½®æŒ‰éˆ•
      const resetBtn = document.createElement('button');
      resetBtn.textContent = 'é‡ç½®è¦–åœ–';
      resetBtn.className = 'small';
      resetBtn.style.position = 'absolute';
      resetBtn.style.top = '90px';
      resetBtn.style.right = '10px';
      resetBtn.style.zIndex = '1000';
      resetBtn.onclick = function () {
        state.zoom = 1;
        state.pan = { x: 0, y: 0 };
        updateViewTransform();
        alert('è¦–åœ–å·²é‡ç½®');
      };

      document.body.appendChild(debugBtn);
      document.body.appendChild(resetBtn);
      // åŠ å…¥ä¸€äº›ç¯„ä¾‹è³‡æ–™
      setTimeout(() => {
        // è‡ªåŠ¨å»ºç«‹ä¸€ä¸ªç¤ºä¾‹åœºåœ°ï¼ˆå¦‚æœæ²¡æœ‰åœºåœ°ï¼‰
        if (state.polygon.length === 0) {
          // æ ¹æ® SVG å°ºå¯¸è®¡ç®—å±…ä¸­ä½ç½®
          const svgWidth = 1200;
          const svgHeight = 700;
          const margin = 100;

          state.polygon = [
            [margin, margin],
            [svgWidth - margin, margin],
            [svgWidth - margin, svgHeight - margin],
            [margin, svgHeight - margin]
          ];
          state.polygonClosed = true;
          renderPolygon();
          showAreaInfo();
          setMode('select');
        }

        // åŠ å…¥ä¸€äº›ç¤ºä¾‹å‡ºå…¥å£
        if (state.entrances.length === 0) {
          const centerX = 600;
          const centerY = 350;
          addEntrance(centerX - 200, centerY);
          addEntrance(centerX + 200, centerY);
        }
      }, 500);

    }
    // ========== ç©ºé—´æœ€ä¼˜åŒ–æ’åˆ— ==========
    function arrangeEfficiently(items, bbox, aisleWidth) {
      const placed = [];
      const gridSize = 10; // ç½‘æ ¼å¤§å°
      const grid = {};

      // åˆ›å»ºç½‘æ ¼å ç”¨è¡¨
      for (let x = bbox.xmin; x < bbox.xmax; x += gridSize) {
        for (let y = bbox.ymin; y < bbox.ymax; y += gridSize) {
          const key = `${Math.floor(x / gridSize)}_${Math.floor(y / gridSize)}`;
          grid[key] = false; // ç©ºé—²
        }
      }

      // æŒ‰é¢ç§¯ä»å¤§åˆ°å°æ’åº
      items.sort((a, b) => (b.width * b.height) - (a.width * a.height));

      // å°è¯•æ”¾ç½®æ¯ä¸ªç‰©å“
      for (const item of items) {
        let placedItem = null;

        // ä»å·¦ä¸Šè§’å¼€å§‹æ‰«æ
        for (let y = bbox.ymin; y + item.height <= bbox.ymax; y += gridSize) {
          for (let x = bbox.xmin; x + item.width <= bbox.xmax; x += gridSize) {
            const centerX = x + item.width / 2;
            const centerY = y + item.height / 2;

            // æ£€æŸ¥æ˜¯å¦åœ¨åœºåœ°å†…ä¸”æ— ç¢°æ’
            if (isRectInPolygon(centerX, centerY, item.width, item.height, state.polygon) &&
              !checkCollision(centerX, centerY, item.width, item.height, placed)) {

              // æ£€æŸ¥ç½‘æ ¼æ˜¯å¦è¢«å ç”¨
              const startGridX = Math.floor(x / gridSize);
              const startGridY = Math.floor(y / gridSize);
              const endGridX = Math.floor((x + item.width) / gridSize);
              const endGridY = Math.floor((y + item.height) / gridSize);

              let canPlace = true;
              for (let gx = startGridX; gx <= endGridX; gx++) {
                for (let gy = startGridY; gy <= endGridY; gy++) {
                  const key = `${gx}_${gy}`;
                  if (grid[key]) {
                    canPlace = false;
                    break;
                  }
                }
                if (!canPlace) break;
              }

              if (canPlace) {
                // æ ‡è®°ç½‘æ ¼ä¸ºå·²å ç”¨
                for (let gx = startGridX; gx <= endGridX; gx++) {
                  for (let gy = startGridY; gy <= endGridY; gy++) {
                    const key = `${gx}_${gy}`;
                    grid[key] = true;
                  }
                }

                placedItem = {
                  id: `auto_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                  type: item.type,
                  customName: item.customName,
                  x: centerX,
                  y: centerY,
                  width: item.width,
                  height: item.height,
                  icon: item.icon,
                  color: item.color,
                  meta: item.meta
                };

                placed.push(placedItem);
                break;
              }
            }
          }
          if (placedItem) break;
        }

        // å¦‚æœæ ‡å‡†ç½‘æ ¼æ”¾ç½®å¤±è´¥ï¼Œå°è¯•è‡ªç”±æ”¾ç½®
        if (!placedItem) {
          const randomPos = findRandomFreeSpot(item.width, item.height);
          if (randomPos) {
            placedItem = {
              id: `auto_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              type: item.type,
              customName: item.customName,
              x: randomPos.x,
              y: randomPos.y,
              width: item.width,
              height: item.height,
              icon: item.icon,
              color: item.color,
              meta: item.meta
            };
            placed.push(placedItem);
          }
        }
      }

      return placed;
    }
    // ========== é é¢è¼‰å…¥æ™‚åˆå§‹åŒ– ==========
    document.addEventListener('DOMContentLoaded', initApp);

    // ========== ä¿®æ­£ iOS è§¸æ§å•é¡Œ ==========
    document.addEventListener('touchstart', (e) => {
      if (e.touches.length > 1) {
        e.preventDefault();
      }
    }, { passive: false });

    document.addEventListener('gesturestart', (e) => {
      e.preventDefault();
    });

  </script>
</body>

</html>
